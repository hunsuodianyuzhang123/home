# 3.0第三阶段-服务端全家桶Ajax+Git+Node.js---刘龙彬

https://www.bilibili.com/video/BV11N411o7wU

## 一、服务器的基本概念和初始AJax

### 1.客户端与服务器

#### 1.1 上网的目的

- 刷微博
- 浏览新闻
- 在线听音乐
- 在线看电影
- etc...

上网的本质目的：通过互联网的形式来获取和消费资源。

#### 1.2 服务器

上网过程中，负责存放和对外提供资源的电脑，叫做服务器。

服务器的概念：在因特网中，负责存放和对外提供资源的电脑。

服务器的本质：就是一台电脑,只不过，它的性能要比个人电脑高很多。

#### 1.3 客户端

上网过程中，负责获取和消费资源的电脑，叫做客户端。

客户端的概念：在因特网中，负责获取和消费资源的电脑。

个人电脑中，可以通过安装浏览器的形式，访问服务器对外提供的各种资源。

### 2.URL地址

#### 2.1 URL地址的概念

URL(全称是UniformResourceLocator)中文叫统一资源定位符，用于标识互联网上每个资源的唯一存放位置。浏览器只有通过URL地址，才能正确定位资源的存放位置，从而成功访问到对应的资源。

常见的URL举例:

- http://www.baidu.com
- http://www.taobao.com
- http://www.cnblogs.com/liulongbinblogs/p/11649393.html

#### 2.2 URL地址的组成部分

URL地址一般由三部组成：
①客户端与服务器之间的通信协议
②存有该资源的服务器名称
③资源在服务器上具体的存放位置

![image-20211124104619037](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211124104619037.png)

### 3.分析网页的打开过程(客户端与服务器的通信过程)

#### 3.1 图解客户端与服务器的通信过程

![image-20211124104931967](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211124104931967.png)

注意：
①客户端与服务器之间的通信过程，分为请求 - 处理 - 响应三个步骤。
②网页中的每一个资源，都是通过请求 - 处理 - 响应的方式从服务器获取回来的。

#### 3.2 基于浏览器的开发者工具分析通信过程

![image-20211124105050981](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211124105050981.png)

1. 打开Chrome浏览器
2. Ctrl+Shift+l打开Chrome的开发者工具
3. 切换到J Network 面板
4. 选中Doc页签
5. 刷新页面，分析客户碳与服务器的通信过程

### 4.服务器对外提供了哪些资源

#### 4.1 例举网页中常见的资源

- 文字内容
- lmage图片
- Audio音频
- Video视频
- and so on...

思考：网页中的数据是不是资源？

#### 4.2 数据也是资源

网页中的数据，也是服务器对外提供的一种资源。例如股票数据、各行业排行榜等。

#### 4.3 数据是网页的灵魂

- HTML是网页的骨架
- CSS是网页的颜值
- Javascript是网页的行为
- 数据，则是网页的灵魂

#### 4.4 网页中如何请求数据

数据，也是服务器对外提供的一种资源。只要是资源，必然要通过请求 – 处理 – 响应的方式进行获取。

![image-20211124105740703](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211124105740703.png)

如果要在网页中请求服务器上的数据资源，则需要用到 `XMLHttpRequest` 对象。

XMLHttpRequest(简称xhr)是浏览器提供的js成员，通过它，可以请求服务器上的数据资源。

最简单的用法

```javascript
var xhrObj = new XMLHttpRequest()
```

#### 4.5 资源的请求方式

客户端请求服务器时，请求的方式有很多种，最常见的两种请求方式分别为get和post 请求。

- get 请求通常用于获取服务端资源(向服务器要资源)
- 例如：根据URL地址，从服务器获取HTML文件、css文件、js文件、图片文件、数据资源等。
- post 请求通常用于向服务器提交数据(往服务器发送资源)
- 例如：登录时向服务器提交的登录信息、注册时向服务器提交的注册信息、添加用户时向服务器提交的用户信息等各种数据提交操作。

### 5.了解Ajax

#### 5.1 什么是Ajax

Ajax的全称是Asynchronous Javascript And XML(异步JavaScript和XML)。

通俗的理解：在网页中利用XMLHttpRequest对象和服务器进行数据交互的方式，就是Ajax。

#### 5.2 为什么要学Ajax

之前所学的技术，只能把网页做的更美观漂亮，或添加一些动画效果，但是，Ajax能让我们轻松实现网页与服务器之间的数据交互。

![image-20211124110342976](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211124110342976.png)

#### 5.3 Ajax的典型应用场景

- 用户名检测：注册用户时，通过ajax的形式，动态检测用户名是否被占用。
- 搜索提示：当输入搜索关键字时，通过ajax的形式，动态加载搜索提示列表。
- 数据分页显示：当点击页码值的时候，通过ajax 的形式，根据页码值动态刷新表格的数据。
- 数据的增删改查：数据的添加、删除、修改、查询操作，都需要通过ajax的形式，来实现数据的交互。

### 6.jQuery中的Ajax

#### 6.1 了解jQuery中的Ajax

浏览器中提供的XMLHttpRequest 用法比较复杂，所以jQuery对 XMLHttpRequest进行了封装，提供了一系列Ajax相关的函数，极大地降低了Ajax的使用难度。

jQuery中发起 Ajax请求最常用的三个方法如下:

- `$.get()`
- `$.post()`
- `$.ajax()`

#### 6.2 $.get()函数的语法

jQuery 中 `$.get()` 函数的功能单一，专门用来发起get请求，从而将服务器上的资源请求到客户端来进行使用。

`$.get()` 函数的语法如下：

```javascript
$.get(url, [data], [callback])
```

其中，三个参数各自代表的含义如下：

| 参数名   | 参数类型 | 是否必选 | 说明                     |
| -------- | -------- | -------- | ------------------------ |
| url      | string   | 是       | 要请求的资源地址         |
| data     | object   | 否       | 请求资源期间要携带的参数 |
| callback | function | 否       | 请求成功时的回调函数     |

#### 6.2 $.get()发起不带参数的请求

使用 `$.get()` 函数发起不带参数的请求时，直接提供请求的URL地址和请求成功之后的回调函数即可，示例代码如下：

```javascript
$.get('http://www.liulongbin.top:3006/api/getbooks', function (res) {
  console.log(res) // 这里的res 是服务器返回的数据
})
```

#### 6.2 $.get()发起带参数的请求

使用 `$.get()` 函数发起带参数的请求时，示例代码如下：

```javascript
$.get('http://www.liulongbin.top:3006/api/getbooks', { id: 1 }, function (res) {
  console.log(res)
})
```

#### 6.3 $.post()函数的语法

jQuery 中 `$.post()` 函数的功能单一，专门用来发起post请求，从而向服务器提交数据。

`$.post()` 函数的语法如下：

```javascript
$.post(url, [data], [callback])
```

其中，三个参数各自代表的含义如下：

| 参数名   | 参数类型 | 是否必选 | 说明                     |
| -------- | -------- | -------- | ------------------------ |
| url      | string   | 是       | 提交数据的地址           |
| data     | object   | 否       | 要提交的数据             |
| callback | function | 否       | 数据提交成功时的回调函数 |

#### 6.3 $.post()向服务器提交数据

使用 `$.post()` 向服务器提交数据的示例代码如下：

```javascript
$.post(
  'http://www.liulongbin.top:3006/api/addbook', // 请求的URL地址
  { bookname: '水浒传', author: '施耐庵', publisher: '上海图书出版社' }, // 提交的数据
  function (res) {
    // 回调函数
    console.log(res)
  }
)
```

#### 6.4 $.ajax()函数的语法

相比于 `$.get()` 和 `$.post()` 函数，jQuery中提供的 `$.ajax()` 函数，是一个功能比较综合的函数，它允许我们对Ajax请求进行更详细的配置。

`$.ajax()` 函数的基本语法如下：

```javascript
$.ajax({
  type: '', // 请求的方式,例如GET或POST
  url: '', // 请求的URL地址
  data: {}, // 这次请求要携带的数据
  success: function (res) {}, // 请求成功之后的回调函数
})
```

#### 6.4 使用$.ajax()发起GET请求

使用 `$.ajax()` 发起GET 请求时，只需要将 type 属性的值设置为'GET'即可：

```javascript
$.ajax({
  type: 'GET', // 请求的方式
  url: 'http://www.liulongbin.top:3006/api/getbooks', // 请求的URL地址
  data: { id: 1 }, // 这次请求要携带的数据
  success: function (res) { // 请求成功之后的回调函数
    console.log(res)
  },
})
```

#### 6.4 使用$.ajax()发起POST请求

使用 `$.ajax()` 发起POST 请求时，只需要将type 属性的值设置为'POST'即可：

```javascript
$.ajax({
  type: 'POST', // 请求的方式
  url: 'http://www.liulongbin.top:3006/api/addbook', // 请求的URL地址
  data: { // 要提交给服务器的数据
    bookname: '水浒传',
    author: '施耐庵',
    publisher: '上海图书出版社',
  },
  success: function (res) { // 请求成功之后的回调函数
    console.log(res)
  },
})
```

### 7.接口

#### 7.1 接口的概念

使用Ajax请求数据时，被请求的URL地址，就叫做数据接口(简称接口)。同时，每个接口必须有请求方式。

例如：

- http://www.liulongbin.top:3006/api/getbooks	获取图书列表的接口(GET请求)
- http://www.liulongbin.top:3006/api/addbook	添加图书的接口(POST请求)

#### 7.2 分析接口的请求过程

##### 1.通过GET方式请求接口的过程

![image-20211124123058607](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211124123058607.png)

##### 2.通过POST方式请求接口的过程

![image-20211124123226811](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211124123226811.png)

#### 7.3 接口测试工具

##### 1.什么是接口测试工具

为了验证接口能否被正常被访问，我们常常需要使用接口测试工具，来对数据接口进行检测。

好处：接口测试工具能让我们在不写任何代码的情况下，对接口进行调用和测试。

- PostMan

##### 2.下载并安装PostMan

访问PostMan的官方下载网址：https://www.getpostman.com/downloads，下载所需的安装程序后，直接安装即可。

##### 3.了解PostMan界面的组成部分

PostMan界面的组成部分，从上到下，从左到右。分别是：

- 菜单栏
- 工具栏
- 左侧历史记录与集合面板
- 请求页签
- 请求地址区域
- 请求参数区域
- 响应结果区域
- 状态栏

#### 7.4 使用PostMan测试GET接口

步骤：
1.选择请求的方式
2.填写请求的URL地址
3.在Params内填写请求的参数
4.点击Send 按钮发起 GET请求
5.查看服务器响应的结果

#### 7.5 使用PostMan测POST接口

步骤：
1.选择请求的方式
2.填写请求的URL地址
3.选择Body面板并勾选数据格式x-www-form-urlencoded
4.填写要发送到服务器的数据
5.点击Send按钮发起POST请求
6.查看服务器响应的结果

### 8.案例-图书管理

#### 8.1 渲染UI结构

![image-20211124124801190](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211124124801190.png)

#### 8.2 案例用到的库和插件

- 用到的css库  bootstrap.css
- 用到的javascript库  jquery.js
- 用到的 vs code插件  Bootstrap 3 Snippets

#### 8.3 渲染图书列表(核心代码)

```javascript
function getBookList() {
  // 1. 发起ajax请求获取图书列表数据
  $.get('http://www.liulongbin.top:3006/api/getbooks', function (res) {
    // 2. 获取列表数据是否成功
    if (res.status !== 200) return alert('获取图书列表失败! ')
    // 3. 渲染页面结构
    var rows = []
    $.each(res.data, function (i, item) {
      // 4. 循环拼接字符串
      rows.push(
        '<tr><td>' + item.id + '</td><td>' + item.bookname + '</td><td>' + item.author + '</td><td>' + item.publisher + '</td><td><a href="javascript:;">删除</a></td></tr>'
      )
    })
    $('#bookBody').empty().append(rows.join('')) // 5. 渲染表格结构
  })
}
```

### 9.案例-聊天机器人(略)

#### 9.1 演示案例要完成的效果

![image-20211124141004555](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211124141004555.png)

实现步骤：
①梳理案例的代码结构
②将用户输入的内容渲染到聊天窗口
③发起请求获取聊天消息
④将机器人的聊天内容转为语音
⑤通过 `<audio>` 播放语音
⑥使用回车键发送消息

#### 9.2 梳理案例的代码结构

①梳理页面的UI布局
②将业务代码抽离到chat.js中
③了解 resetui()函数的作用

#### 9.3 剩余的略过



## 二、form表单域模板引擎

### 1.form表单的基本使用

#### 1.1 什么是表单

表单在网页中主要负责数据采集功能。HTML中的 `<form>` 标签，就是用于采集用户输入的信息，并通过 `<form>` 标签的提交操作，把采集到的信息提交到服务器端进行处理。

```html
<form>
  <input type="text" name="email_or_mobile" />
  <input type="password" name="password" />
  <input type="checkbox" name="remember_me" checked />
  <button type="submit">提交</button>
</form>
```

#### 1.2 表单的组成部分

表单由三个基本部分组成：

- 表单标签 `form`
- 表单域 `input` ：包含了文本框、密码框、隐藏域、多行文本框、复选框、单选框、下拉选择框和文件上传框等。
- 表单按钮 `button`

#### 1.3 `<form>` 标签的属性

`<form>` 标签用来采集数据，`<form>` 标签的属性则是用来规定如何把采集到的数据发送到服务器。

| 属性    | 值                                                           | 描述                                     |
| ------- | ------------------------------------------------------------ | ---------------------------------------- |
| action  | URL地址                                                      | 规定当提交表单时，向何处发送表单数据     |
| method  | get或post                                                    | 规定以何种方式把表单数据提交到action URL |
| enctype | application/x-www-form-urlencoded<br />multipart/form-data<br />text/plain | 规定在发送表单数据之前如何对其进行编码   |
| target  | `_blank`<br/>`_self`<br/>`_parent`<br>`_top`<br/>`framename` | 规定在何处打开action URL                 |

##### 1.action

action 属性用来规定当提交表单时，向何处发送表单数据。

action属性的值应该是后端提供的一个URL地址，这个URL地址专门负责接收表单提交过来的数据。

当 `<form>` 表单在未指定 action属性值的情况下，action的默认值为当前页面的URL 地址。

注意：当提交表单后，页面会立即跳转到action属性指定的 URL地址。

##### 2.target

target属性用来规定在何处打开action URL。

它的可选值有5个，默认情况下，target的值是_self，表示在相同的框架中打开 action URL。

| 值          | 描述                         |
| ----------- | ---------------------------- |
| `_blank`    | 在新窗口中打开。             |
| `_self`     | 默认。在相同的框架中打开。   |
| `_parent`   | 在父框架集中打开。(很少用)   |
| `_top`      | 在整个窗口中打开。(很少用)   |
| `framename` | 在指定的框架中打开。(很少用) |

##### 3.method

method 属性用来规定以何种方式把表单数据提交到action URL。

它的可选值有两个，分别是 get和post。

默认情况下，method的值为get，表示通过URL地址的形式，把表单数据提交到action URL。

注意：
get方式适合用来提交少量的、简单的数据。
post方式适合用来提交大量的、复杂的、或包含文件上传的数据。
在实际开发中， `<form>` 表单的post提交方式用的最多，很少用get。例如登录、注册、添加数据等表单操作，都需要使用post 方式来提交表单。

##### 4.enctype

enctype属性用来规定在发送表单数据之前如何对数据进行编码。

它的可选值有三个，默认情况下，enctype的值为 `application/x-www-form-urlencoded`，表示在发送前编码所有的字符。

| 值                                | 描述                                                         |
| --------------------------------- | ------------------------------------------------------------ |
| application/x-www-form-urlencoded | 在发送前编码所有字符(默认)                                   |
| multipart/form-data               | 不对字符编码。<br/>在使用包含文件上传控件的表单时，必须使用该值。 |
| text/plain                        | 空格转换为“"+”加号，但不对特殊字符编码。(很少用)             |

注意：
在涉及到文件上传的操作时，必须将enctype的值设置为 `multipart/form-data`
如果表单的提交不涉及到文件上传操作，则直接将enctype的值设置为 `application/x-www-form-urlencoded` 即可!

#### 1.4 表单的同步提交及缺点

##### 1.什么是表单的同步提交

通过点击submit按钮，触发表单提交的操作，从而使页面跳转到 action URL的行为，叫做表单的同步提交。

##### 2表单同步提交的缺点

① `<form>` 表单同步提交后，整个页面会发生跳转，跳转到action URL所指向的地址，用户体验很差。
② `<form>` 表单同步提交后，页面之前的状态和数据会丢失。

思考：如何解决上述两个问题?

##### 3.如何解决表单同步提交的缺点

如果使用表单提交数据，则会导致以下两个问题：
①页面会发生跳转
②页面之前的状态和数据会丢失

解决方案：表单只负责采集数据，Ajax负责将数据提交到服务器。

### 2.通过Ajax提交表单数据

#### 2.1 监听表单提交事件

在jQuery中，可以使用如下两种方式，监听到表单的提交事件：

```javascript
$('#form1').submit(function (e) {
  alert('监听到了表单的提交事件')
})

$('#form1').on('submit', function (e) {
  alert('监听到了表单的提交事件')
})
```

#### 2.2 阻止表单默认提交行为

当监听到表单的提交事件以后，可以调用事件对象的 `event.preventDefault()` 函数，来阻止表单的提交和页面的跳转，示例代码如下：

```javascript
$('#form1').submit(function (e) {
  // 阻止表单的提交和页面的跳转
  e.preventDefault()
})

$('#form1').on('submit', function (e) {
  // 阻止表单的提交和页面的跳转
  e.preventDefault()
})
```

#### 2.3 快速获取表单中的数据

##### 1.serialize()函数

为了简化表单中数据的获取操作，jQuery提供了 `serialize()` 函数，其语法格式如下：

```javascript
$(selector).serialize()
```

`serialize()` 函数的好处：可以一次性获取到表单中的所有的数据。

##### 2.serialize()函数示例

```html
<form id="form1">
  <input type="text" name="username" />
  <input type="password" name="password" />
  <button type="submit">提交</button>
</form>
```

```javascript
$('#form1').serialize()
// 调用的结果:
// username=用户名的值&password=密码的值
```

注意：在使用 `serialize()` 函数快速获取表单数据时，必须为每个表单元素添加name 属性！

### 3.案例-评论列表

#### 3.1 渲染UI结构

![image-20211125071953241](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211125071953241.png)

#### 3.2 获取评论列表

```javascript
function getCmtList() {
  $.get('http://www.liulongbin.top:3006/api/cmtlist', function (res) {
    if (res.status !== 200) {
      return alert('获取评论列表失败!')
    }
    var rows = []
    $.each(res.data, function (i, item) {
      // 循环拼接字符串
      rows.push(
        '<li class="list-group-item">' +
          item.content +
          '<span class="badge cmt-date">评论时间:' +
          item.time +
          '</span><span class="badge cmt-person">评论人:' +
          item.username +
          '</span></li>'
      )
    })
    $('#cmt-list').empty().append(rows.join(' ')) // 渲染列表的uI结构
  })
}
```

### 4.模板引擎的基本概念

#### 4.1 渲染UI结构时遇到的问题

```javascript
var rows = []
$.each(res.data, function (i, item) {
  // 循环拼接字符串
  rows.push(
    '<li class="list-group-item">' +
      item.content +
      '<span class="badge cmt-date">评论时间：' +
      item.time +
      '</span><span class="badge cmt-person">评论人：' +
      item.username +
      '</span></li>'
  )
})
$('#cmt-list').empty().append(rows.join(' ')) // 渲染列表的UI结构
```

上述代码是通过字符串拼接的形式，来渲染Ul结构。

如果U结构比较复杂，则拼接字符串的时候需要格外注意引号之前的嵌套。且一旦需求发生变化，修改起来也非常麻烦。

#### 4.2 什么是模板引擎

模板引擎，顾名思义，它可以根据程序员指定的模板结构和数据，自动生成一个完整的HTML 页面。

![image-20211125074150262](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211125074150262.png)

#### 4.3 模板引擎的好处

①减少了字符串的拼接操作
②使代码结构更清晰
③使代码更易于阅读与维护

### 5.art-template模板引擎(略)

#### 5.1 art-template简介

art-template是一个简约、超快的模板引擎。

中文官网首页为：http://aui.github.io/art-template/zh-cn/index.html

![image-20211125074437265](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211125074437265.png)

#### 5.2 art-template的安装

在浏览器中访问：http://aui.github.io/art-template/zh-cn/docs/installation.html页面，找到下载链接后，鼠标右键，选择”链接另存为”，将art-template下载到本地，然后，通过 `<script>` 标签加载到网页上进行使用。

#### 5.3 art-template模板引擎的基本使用

##### 1.使用传统方式渲染UI结构

```javascript
var data = {
  title: '<h3>用户信息</h3>',
  name: 'zs',
  age: 20,
  isyIP: true,
  regTime: new Date(),
  hobby: ['吃饭', '睡觉', '打豆豆'],
}
```

![image-20211125074826868](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211125074826868.png)

##### 2.art-template的使用步骤

①导入art-template
②定义数据
③定义模板
④调用template函数
⑤渲染HTML结构

#### 5.4 art-template标准语法

##### 1.什么是标准语法

art-template提供了 `{{ }}` 这种语法格式，在 `{{ }}` 内可以进行变量输出，或循环数组等操作，这种 `{{ }}` 语法在art- template中被称为标准语法。

##### 2.标准语法-输出

```
{{value}}
{{obj.key}}
{{obj['key']}}
{{a ? b : c}}
{{a || b}}
{{a + b}}
```

在 `{{}}` 语法中，可以进行变量的输出、对象属性的输出、三元表达式输出、逻辑或输出、加减乘除等表达式输出。

##### 3.剩余的略过



#### 5.5 剩余的略过



### 6.模板引擎的实现原理(略)

#### 6.1 正则与字符串操作

##### 1.基本语法

`exec()` 函数用于检索字符串中的正则表达式的匹配。

如果字符串中有匹配的值，则返回该匹配值，否则返回null。

```javascript
RegExpObject.exec(string)
```

示例代码如下：

```javascript
var str = 'hello'
var pattern = /o/
// 输出的结果["o", index: 4, input: "hello", groups: undefined]
console.log(pattern.exec(str))
```

##### 2.分组

正则表达式中()包起来的内容表示个分组，可以通过分组来提取自己想要的内容，示例代码如下：

```javascript
var str = '<div>我是{{name}}</div>'
var pattern = /{{([a-zA-Z]+)}}/

var patternResult = pattern.exec(str)
console.log(patternResult)
// 得到name相关的分组信息
// ["{{name}}", "name", index: 7, input: "<div> 我是{{name}}</div>", groups: undefined]
```

##### 3.字符串的replace函数

`replace()` 函数用于在字符串中用一些字符替换另一 些字符，语法格式如下：

```javascript
var result = '123456'.replace('123', 'abe') // 得到的result 的值为字符串' abc456'
```

示例代码如下:

```javascript
var str = '<div>我是{{name}}</div>'
var pattern = /{{([a-zA-Z]+)}}/

var patternResult = pattern.exec(str)
str = str.replace(patternResult[0], patternResult[1]) // replace 函数返回值为替换后的新宇符串
// 输出的内容是: <div>我是name</div>
console.log(str)
```

##### 4.多次replace

```javascript
var str = '<div>{{ name }}今年{{ age }}岁了</div>'
var pattern = /{{\s*([a-zA-Z]+)\s*}}/

var patternResult = pattern.exec(str)
str = str.replace(patternResult[0], patternResult[1])
console.log(str) // 输出<div>name今年({ age }1岁 了</div>

patternResult = pattern.exec(str)
str = str.replace(patternResult[0], patternResult[1])
console.log(str) // 输出<div>name今 年age岁了</div>

patternResult = pattern.exec(str)
console.log(patternResult) // 输出null
```

##### 5.使用while循环replace

```javascript
var str = '<div>{{name}}今年{{ age }}岁了</div>'
var pattern = /{{\s*([a-zA-Z]+)\s*}}/

var patternResult = null
while ((patternResult = pattern.exec(str))) {
  str = str.replace(patternResult[0], patternResult[1])
}
console.log(str) // 输出 <div>name今年age岁了
```

##### 6.replace替换为真值

```javascript
var data = { name: '张三', age: 20 }

var str = '<div>{{name}}今年{{ age }}岁了</div>'
var pattern = /{{\s*([a-zA-Z]+)\s*}}/

var patternResult = null
while ((patternResult = pattern.exec(str))) {
  str = str.replace(patternResult[0], data[patternResult[1]])
}
console.log(str)
```

#### 6.2 实现简易的模板引擎(略)

##### 1.实现步骤

①定义模板结构
②预调用模板引擎
③封装template函数
④导入并使用自定义的模板引擎



## 三、Ajax加强

### 1.XMLHttpRequest的基本使用

#### 1.1 什么XMLHttpRequest

XMLHttpRequest (简称xhr)是浏览器提供的Javascript对象，通过它，可以请求服务器上的数据资源。之前所学的jQuery中的Ajax函数，就是基于xhr对象封装出来的。

![image-20211125084726755](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211125084726755.png)

思考：能否直接使用xhr对象发起Ajax请求？

#### 1.2 使用xhr发起GET请求

步骤：
①创建xhr对象
②调用 `xhr.open()` 函数
③调用 `xhr.send()` 函数
④监听 `xhr.onreadystatechange` 事件

```javascript
// 1.创建XHR对象
var xhr = new XMLHttpRequest()
// 2.调用open函数，指定请求方式与URL地址
xhr.open('GET', 'http://www.liulongbin.top:3006/api/getbooks')
// 3.调用send函数，发起Ajax请求
xhr.send()
// 4.监听onreadystatechange事件
xhr.onreadystatechange = function () {
  // 4.1监听xhr对象的请求状态readyState；与服务器响应的状态status
  if (xhr.readyState === 4 && xhr.status === 200) {
    // 4.2打印服务器响应回来的数据
    console.log(xhr.responseText)
  }
}
```

#### 1.3 了解xhr对象的readyState属性

XMLHttpRequest 对象的readyState属性，用来表示当前Ajax 请求所处的状态。每个Ajax 请求必然处于以下状态中的一个：

| 值   | 状态             | 描述                                                |
| :--- | :--------------- | --------------------------------------------------- |
| 0    | UNSENT           | XMLHttpRequest 对象已被创建，但尚未调用open方法。   |
| 1    | OPENED           | open()方法已经被调用。                              |
| 2    | HEADERS_RECEIVED | send() 方法已经被调用，响应头也已经被接收。         |
| 3    | LOADING          | 数据接收中，此时response 属性中已经包含部分数据。   |
| 4    | DONE             | Ajax 请求完成，这意味着数据传输已经彻底完成或失败。 |

#### 1.4 使用xhr发起带参数的GET请求

使用xhr 对象发起带参数的GET 请求时，只需在调用xhr.open期间，为URL 地址指定参数即可：

```javascript
// ...省略不必要的代码
xhr.open('GET', 'http://www.liulongbin.top:3006/api/getbooks?id=1')
//...省略不必要的代码
```


这种在URL 地址后面拼接的参数，叫做查询字符串。

#### 1.5 查询字符串

##### 1.什么是查询字符串

定义：查询字符串(URL 参数)是指在URL 的末尾加上用于向服务器发送信息的字符串(变量)。

格式：将英文的？放在URL 的末尾，然后再加上 **参数＝值** ，想加上多个参数的话，使用 **&** 符号进行分隔。以这个形式，可以将想要发送给服务器的数据添加到URL 中。

```
// 不带参数的URL 地址
http://www.liulongbin.top:3006/api/getbooks
// 带一个参数的URL 地址
http://www.liulongbin.top:3006/api/getbooks?id=1
// 带两个参数的URL 地址
http://www.liulongbin.top:3006/api/getbooks?id=1&bookname=西游记
```

##### 2.GET请求携带参数的本质

无论使用$.ajax()，还是使用$.get()，又或者直接使用xhr 对象发起GET 请求，当需要携带参数的时候，本质上，都是直接将参数以查询字符串的形式，追加到URL 地址的后面，发送到服务器的。

```javascript
$.get('url', { name: 'zs', age: 20 }, function () {})
// 等价于
$.get('url?name=zs&age=20', function () {})

$.ajax({
  method: 'GET',
  url: 'url',
  data: { name: 'zs', age: 20 },
  success: function () {},
})
// 等价于
$.ajax({
  method: 'GET',
  url: 'url?name=zs&age=20',
  success: function () {},
})
```

#### 1.6 URL编码与解码

##### 1.什么是URL编码

URL 地址中，只允许出现英文相关的字母、标点符号、数字，因此，在URL 地址中不允许出现中文字符。

如果URL 中需要包含中文这样的字符，则必须对中文字符进行编码 (转义)。

URL编码的原则：使用安全的字符 (没有特殊用途或者特殊意义的可打印字符) 去表示那些不安全的字符。

URL编码原则的通俗理解：使用英文字符去表示非英文字符。

```
http://www.liulongbin.top:3006/api/getbooks?id=1&bookname=西游记
// 经过URL 编码之后，URL地址变成了如下格式：
http://www.liulongbin.top:3006/api/getbooks?id=1&bookname=%E8%A5%BF%E6%B8%B8%E8%AE%B0
```

##### 2.如何对URL进行编码与解码

浏览器提供了URL 编码与解码的API，分别是：

- `encodeURI()` 编码的函数
- `decodeURI()` 解码的函数

```javascript
encodeURI('黑马程序员')
// 输出字符串%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98
decodeURI('%E9%BB%91%E9%A9%AC')
// 输出字符串黑马
```

##### 3.URL编码的注意事项

由于浏览器会自动对URL 地址进行编码操作，因此，大多数情况下，程序员不需要关心URL 地址的编码与解码操作。

更多关于URL 编码的知识，请参考如下博客：
https://blog.csdn.net/Lxd_0111/article/details/78028889

#### 1.7 使用xhr发起POST请求

步骤：
①创建xhr对象
②调用 `xhr.open()` 函数
③设置 `Content-Type` 属性(固定写法)
④调用 `xhr.send()` 函数，同时指定要发送的数据
⑤监听 `xhr.onreadystatechange` 事件

```javascript
// 1. 创建xhr 对象
var xhr = new XMLHttpRequest()
// 2. 调用open()
xhr.open('POST', 'http://www.liulongbin.top:3006/api/addbook')
// 3. 设置Content-Type属性（固定写法）
xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded')
// 4. 调用send()，同时将数据以查询字符串的形式，提交给服务器
xhr.send('bookname=水浒传&author=施耐庵&publisher=天津图书出版社')
// 5. 监听onreadystatechange 事件
xhr.onreadystatechange = function () {
  if (xhr.readyState === 4 && xhr.status === 200) {
    console.log(xhr.responseText)
  }
}
```

### 2.数据交换格式

#### 2.1 什么是数据交换格式

数据交换格式，就是服务器端与客户端之间进行数据传输与交换的格式。

前端领域，经常提及的两种数据交换格式分别是**XML**和**JSON**。其中XML 用的非常少，所以，我们重点要学习的数据交换格式就是JSON。

![image-20211125114258745](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211125114258745.png)

#### 2.2 XML

##### 1.什么是XML

XML 的英文全称是E**X**tensible **M**arkup **L**anguage，即可扩展标记语言。因此，XML 和HTML 类似，也是一种标记语言。

**HTML**

```html
<!DOCTYPEhtml>
<html>
  <head>
    <title>Document</title>
  </head>
  <body></body>
</html>
```

**XML**

```xml
<note>
  <to>ls</t0>
  <from>zs</from>
  <heading>通知</heading>
  <body>晚上开会</body>
</note>
```

##### 2.XML和HTML的区别

XML 和HTML 虽然都是标记语言，但是，它们两者之间没有任何的关系。

- HTML 被设计用来描述网页上的内容，是网页内容的载体
- XML 被设计用来传输和存储数据，是数据的载体

![image-20211125114458237](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211125114458237.png)

![image-20211125114508450](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211125114508450.png)

##### 3.XML的缺点

```xml
<note>
  <to>ls</t0>
  <from>zs</from>
  <heading>通知</heading>
  <body>晚上开会</body>
</note>
```

①XML 格式臃肿，和数据无关的代码多，体积大，传输效率低
②在Javascript 中解析XML 比较麻烦

#### 2.3 JSON

##### 1.什么是JSON

概念：JSON 的英文全称是**J**ava**S**cript **O**bject **N**otation，即“JavaScript 对象表示法”。简单来讲，JSON 就是Javascript 对象和数组的字符串表示法，它使用文本表示一个JS 对象或数组的信息，因此，**JSON 的本质是字符串**。

作用：JSON 是一种轻量级的文本数据交换格式，在作用上类似于XML，专门用于存储和传输数据，但是JSON 比XML 更小、更快、更易解析。

现状：JSON 是在2001 年开始被推广和使用的数据格式，到现今为止，**JSON 已经成为了主流的数据交换格式**。

##### 2.JSON的两种结构

JSON 就是用字符串来表示Javascript 的对象和数组。所以，JSON 中包含对象和数组两种结构，通过这两种结构的相互嵌套，可以表示各种复杂的数据结构。

**对象结构**：对象结构在JSON 中表示为{ } 括起来的内容。数据结构为 `{ key: value, key: value, … }` 的键值对结构。其中，key 必须是使用 **英文的双引号** 包裹的字符串，value 的数据类型可以是 **数字、字符串、布尔值、null、数组、对象** 6种类型。

**数组结构**：数组结构在JSON 中表示为[ ] 括起来的内容。数据结构为 `[ "java", "javascript", 30, true … ]` 。数组中数据的类型可以是**数字、字符串、布尔值、null、数组、对象**6种类型。

##### 3.JSON语法注意事项

①属性名必须使用双引号包裹
②字符串类型的值必须使用双引号包裹
③JSON 中不允许使用单引号表示字符串
④JSON 中不能写注释
⑤JSON 的最外层必须是对象或数组格式
⑥不能使用undefined 或函数作为JSON 的值

JSON 的作用：在计算机与网络之间存储和传输数据。
JSON 的本质：用字符串来表示Javascript 对象数据或数组数据。

##### 4.JSON和JS对象的关系

JSON 是JS 对象的字符串表示法，它使用文本表示一个JS 对象的信息，本质是一个字符串。例如：

```javascript
// 这是一个对象
var obj = { a: 'Hello', b: 'World' }

// 这是一个JSON字符串.本质是一一个字符串
var json = '{"a": "Hello", "b": "World"}'
```

##### 5.JSON和JS对象的互转

要实现从JSON 字符串转换为JS 对象，使用 `JSON.parse()` 方法：

```javascript
var obj = JSON.parse('{"a": "Hello", "b": "World"}')
// 结果是(a: 'Hello', b: 'World'}
```


要实现从JS 对象转换为JSON 字符串，使用 `JSON.stringify()` 方法：

```javascript
var json = JSON.stringify({ a: 'Hello', b: 'World' })
// 结果是'{"a": "Hello", "b":hworld"}'
```

##### 6.序列化和反序列化

把数据对象转换为字符串的过程，叫做序列化，例如：调用 `JSON.stringify()` 函数的操作，叫做JSON 序列化。

把字符串转换为数据对象的过程，叫做反序列化，例如：调用 `JSON.parse()` 函数的操作，叫做JSON 反序列化。

### 3.封装自己的Ajax函数

#### 3.1 要实现的效果

```javasript
<!-- 1. 导入自定义的ajax函数库 -->
<script src="./itheima.js"></script>

<script>
  // 2. 调用自定义的itheima函数，发起Ajax 数据请求
  itheima({
    method: '请求类型',
    url: '请求地址',
    data: {
      /* 请求参数对象*/
    },
    success: function (res) {
      // 成功的回调函数
      console.log(res) // 打印数据
    },
  })
</script>
```

#### 3.2 定义options参数选项

`itheima()` 函数是我们自定义的Ajax 函数，它接收一个配置对象作为参数，配置对象中可以配置如下属性：

| 属性    | 意义                   |
| ------- | ---------------------- |
| method  | 请求的类型             |
| url     | 请求的URL 地址         |
| data    | 请求携带的数据         |
| success | 请求成功之后的回调函数 |

#### 3.3 处理data参数

需要把data 对象，转化成查询字符串的格式，从而提交给服务器，因此提前定义resolveData函数如下：

```javascript
// 处理data参数
// @param {data} 需要发送到服务器的数据
// @returns {string} 返回拼接好的查询字符串name=zs&age=10

function resolveData(data) {
  var arr = []
  for (var k in data) {
    arr.push(k + '=' + data[k])
  }
  return arr.join('&')
}
```

#### 3.4 定义itheima函数

在itheima() 函数中，需要创建xhr 对象，并监听onreadystatechange 事件：

```javascript
function itheima(options) {
  var xhr = new XMLHttpRequest()
  // 拼接查询字符串
  var qs = resolveData(options.data)

  // 监听请求状态改变的事件
  xhr.onreadystatechange = function () {
    if (xhr.readyState === 4 && xhr.status === 200) {
      var result = JSON.parse(xhr.responseText)
      options.success(result)
    }
  }
}
```

#### 3.5 判断请求的类型

不同的请求类型，对应xhr 对象的不同操作，因此需要对请求类型进行if … else … 的判断：

```javascript
if (options.method.toUpperCase() === 'GET') {
  // 发起GET请求
  xhr.open(options.method, options.url + ' ?' + qIs)
  xhr.send()
} else if (options.method.toUpperCase() === 'POST') {
  //发起POST请求
  xhr.open(options.method, options.url)
  xhr.setRequestHeader(
    'Content-Type',
    ' application/x-www- form-urlencoded'
  )
  xhr.send(qs)
}
```

### 4.XMLHttpRequest Level2的新特性

#### 4.1 认识XMLHttpRequest Level2

##### 1.旧版XMLHttpRequest的缺点

①只支持文本数据的传输，无法用来读取和上传文件
②传送和接收数据时，没有进度信息，只能提示有没有完成

##### 2.XMLHttpRequestLevel2的新功能

①可以设置HTTP 请求的时限
②可以使用FormData 对象管理表单数据
③可以上传文件
④可以获得数据传输的进度信息

#### 4.2 设置HTTP请求时限

有时，Ajax 操作很耗时，而且无法预知要花多少时间。如果网速很慢，用户可能要等很久。新版本的XMLHttpRequest 对象，增加了timeout 属性，可以设置HTTP 请求的时限：

```javascript
xhr.timeout = 3000
```


上面的语句，将最长等待时间设为3000 毫秒。过了这个时限，就自动停止HTTP请求。与之配套的还有一个timeout 事件，用来指定回调函数：

```javascript
xhr.ontimeout = function(event) {
  alert('请求超时！')
}
```

#### 4.3 FormData对象管理表单数据

Ajax 操作往往用来提交表单数据。为了方便表单处理，HTML5 新增了一个FormData 对象，可以模拟表单操作：

```javascript
// 1.新建FormData 对象
var fd = new FormData()
// 2.为FormData添加表单项
fd.append('uname', 'zs')
fd.append('upwd', '123456')
// 3.创建XHR对象
var xhr = new XMLHttpRequest()
// 4.指定请求类型与URI地址
xhr.open('POST', 'http://www.liulongbin.top:3006/api/formdata')
// 5.直接提交FormData 对象，这与提交网页表单的效果，完全一样
xhr.send(fd)
```

FormData对象也可以用来获取网页表单的值，示例代码如下：

```javascript
var form = document.querySelector('#form1')
// 监听表单元素的submit事件
form.addEventListener(' submit', function (e) {
  e.preventDefault()
  // 根据form表单创建FormData对象，会自动将表单数据填充到FormData对象中
  var fd = new FormData(form)
  var xhr = new XMLHttpRequest()
  xhr.open('POST', 'http://www.liulongbin.top:3006/api/formdata')
  xhr.send(fd)
  xhr.onreadystatechange = function () {}
})
```

#### 4.4 上传文件

新版XMLHttpRequest 对象，不仅可以发送文本信息，还可以上传文件。

实现步骤：
①定义UI 结构
②验证是否选择了文件
③向FormData中追加文件
④使用xhr发起上传文件的请求
⑤监听onreadystatechange事件

##### 1.定义UI结构

```html
<!-- 1. 文件选择框 -->
<input type="file" id="file1" />
<!-- 2. 上传文件的按钮 -->
<button id="btnUpload">上传文件</button>
<br />
<!-- 3. img 标签，来显示上传成功以后的图片 -->
<img src="" alt="" id="img" width="800" />
```

##### 2.验证是否选择了文件

```javascript
// 1. 获取到文件上传按钮
var btnUpload = document.querySelector('#btnUpload')
// 2. 为按钮绑定单击事件处理函数
btnUpload.addEventListener('click', function () {
  // 3. 获取到用户选择的文件列表
  var files = document.querySelector('#file1').files
  if (files.length <= 0) {
    return alert('请选择要上传的文件！')
  }
  // ...后续业务逻辑
})
```

##### 3.向FormData中追加文件

```javascript
// 1. 创建 FormData 对象
var fd = new FormData()
// 2. 向 FormData 中追加文件
fd.append('avatar', files[0])
```

##### 4.使用xhr 发起上传文件的请求

```javascript
// 1. 创建xhr对象
var xhr = new XMLHttpRequest()
// 2. 调用open函数，指定请求类型与URL地址。其中，请求类型必须为 POST
xhr.open('POST', 'http://www.liulongbin.top:3006/api/upload/avatar')
// 3. 发起请求
xhr.send(fd)
```

##### 5.监听onreadystatechange事件

```javascript
xhr.onreadystatechange = function () {
  if (xhr.readyState === 4 && xhr.status === 200) {
    var data = JSON.parse(xhr.responseText)
    if (data.status === 200) {
      // 上传文件成功
      // 将服务器返回的图片地址，设置为<img>标签的src属性
      document.querySelector('#img').src =
        'http://www.liulongbin.top:3006' + data.url
    } else {
      // 上传失败
      console.log('图片上传失败！' + data.message)
    }
  }
}
```

#### 4.5 显示文件上传进度

新版本的XMLHttpRequest 对象中，可以通过监听xhr.upload.onprogress事件，来获取到文件的上传进度。语法格式如下：

```javascript
// 创建XHR对象
var xhr = new XMLHttpRequest()
// 监听 xhr.upload 的onprogress事件
xhr.upload.onprogress = function (e) {
  // e.lengthComputable是一个布尔值，表示当前上传的资源是否具有可计算的长度
  if (e.lengthComputable) {
    // e.loaded已传输的字节
    // e.total需传输的总字节
    var percentcomplete = Math.ceil((e.loaded / e.total) * 100)
  }
}
```

##### 1.导入需要的库

```javascript
<link rel="stylesheet" href="./lib/bootstrap.css" />
<script src="./lib/jquery.js"></script>
```

##### 2.基于Bootstrap渲染进度条

```html
<!-- 进度条 -->
<div class="progress" style="width: 500px; margin: 10px 0;">
  <div class="progress-bar progress-bar-info progress-bar-striped active" id="percent" style="width: 0%">
    0%
  </div>
</div>
```

##### 3.监听上传进度的事件

```javascript
xhr.upload.onprogress = function (e) {
  if (e.lengthComputable) {
    // 1. 计算出当前上传进度的百分比
    var percentComplete = Math.ceil((e.loaded / e.total) * 100)
    $('#percent')
      // 2. 设置进度条的宽度
      .attr('style', 'width:' + percentComplete + '%')
      // 3. 显示当前的上传进度百分比
      .html(percentComplete + '%')
  }
}
```

##### 4.监听上传完成的事件

```javascript
xhr.upload.onload = function () {
  $('#percent')
    // 移除上传中的类样式
    .removeClass()
    // 添加上传完成的类样式
    .addClass('progress-bar progress-bar-success')
}
```

### 5.jQuery高级用法

#### 5.1 jQuery实现文件上传

##### 1.定义UI结构

```html
<!-- 导入 jQuery -->
<script src="./lib/jquery.js"></script>

<!-- 文件选择框 -->
<input type="file" id="file1" />
<!-- 上传文件按钮 -->
<button id="btnUpload">上传</button>
```

##### 2.验证是否选择了文件

```javascript
$('#btnUpload').on('click', function () {
  // 1. 将 jQuery 对象转化为 DOM 对象，并获取选中的文件列表
  var files = $('#file1')[0].files
  // 2. 判断是否选择了文件
  if (files.length <= 0) {
    return alert('请选择图片后再上传！')
  }
})
```

##### 3.向FormData中追加文件

```javascript
// 向 FormData 中追加文件
var fd = new FormData()
fd.append('avatar', files[0])
```

##### 4.使用jQuery发起上传文件的请求

```javascript
$.ajax({
  method: 'POST',
  url: 'http://www.liulongbin.top:3006/api/upload/avatar',
  data: fd,
  // 不修改 Content-Type 属性，使用 FormData 默认的 Content-Type 值
  contentType: false,
  // 不对 FormData 中的数据进行 url 编码，而是将 FormData 数据原样发送到服务器
  processData: false,
  success: function (res) {
    console.log(res)
  },
})
```

#### 5.2 jQuery实现loading效果

##### 1.ajaxStart(callback)

Ajax 请求开始时，执行ajaxStart 函数。可以在ajaxStart 的callback 中显示loading 效果，示例代码如下：

```javascript
// 自 jQuery 版本 1.8 起，该方法只能被附加到文档
$(document).ajaxStart(function () {
  $('#loading').show()
})
```


注意：`$(document).ajaxStart()` 函数会监听当前文档内所有的Ajax 请求。

##### 2.ajaxStop(callback)

Ajax 请求结束时，执行ajaxStop 函数。可以在ajaxStop 的callback 中隐藏loading 效果，示例代码如下：

```javascript
// 自 jQuery 版本 1.8 起，该方法只能被附加到文档
$(document).ajaxStop(function () {
  $('#loading').hide()
})
```

### 6.axios

#### 6.1 什么是axios

Axios 是专注于**网络数据请求**的库。

相比于原生的XMLHttpRequest 对象，axios **简单易用**。

相比于jQuery，axios 更加**轻量化**，只专注于网络数据请求。

#### 6.2 axios发起GET请求

axios 发起get 请求的语法：

```javascript
axios.get('url', { params: { /*参数*/ } }).then(callback)
```


具体的请求示例如下：

```javascript
// 请求的 URL 地址
var url = 'http://www.liulongbin.top:3006/api/get'
// 请求的参数对象
var paramsObj = { name: 'zs', age: 20 }
// 调用 axios.get() 发起 GET 请求
axios.get(url, { params: paramsObj }).then(function (res) {
  // res.data 是服务器返回的数据
  var result = res.data
  console.log(res)
})
```

#### 6.3 axios发起POST请求

axios 发起post 请求的语法：

```javascript
axios.post('url', { /*参数*/ }).then(callback)
```


具体的请求示例如下：

```javascript
// 请求的 URL 地址
var url = 'http://www.liulongbin.top:3006/api/post'
// 要提交到服务器的数据
var dataObj = { location: '北京', address: '顺义' }
// 调用 axios.post() 发起 POST 请求
axios.post(url, dataObj).then(function (res) {
  // res.data 是服务器返回的数据
  var result = res.data
  console.log(result)
})
```

#### 6.4 直接使用axios发起请求

axios 也提供了类似于jQuery 中$.ajax() 的函数，语法如下：

```javascript
axios({
  method: '请求类型',
  url: '请求的URL地址',
  data: { /* POST数据 */ },
  params: { /* GET参数 */ },
}).then(callback)
```

##### 1.直接使用axios发起GET请求

```javascript
axios({
  method: 'GET',
  url: 'http://www.liulongbin.top:3006/api/get',
  params: {
    // GET 参数要通过 params 属性提供
    name: 'zs',
    age: 20,
  },
}).then(function (res) {
  console.log(res.data)
})
```

##### 2.直接使用axios发起POST请求

```javascript
axios({
  method: 'POST',
  url: 'http://www.liulongbin.top:3006/api/post',
  data: {
    // POST 数据要通过 data 属性提供
    bookname: '程序员的自我修养',
    price: 666,
  },
}).then(function (res) {
  console.log(res.data)
})
```

## 四、跨域与JSONP

### 1.了解同源策略和跨域

#### 1.1 同源策略

##### 1.什么是同源

如果两个页面的**协议**，**域名**和**端口**都相同，则两个页面具有相同的源。

例如，下表给出了相对于http://www.test.com/index.html 页面的同源检测：

| URL                                | 是否同源 | 原因                                     |
| :--------------------------------- | :------- | ---------------------------------------- |
| http://www.test.com/other.html     | 是       | 同源（协议、域名、端口相同）             |
| https://www.test.com/about.html    | 否       | 协议不同（http与https）                  |
| http://blog.test.com/movie.html    | 否       | 域名不同（www.test.com 与blog.test.com） |
| http://www.test.com:7001/home.html | 否       | 端口不同（默认的80端口与7001端口）       |
| http://www.test.com:80/main.html   | 是       | 同源（协议、域名、端口相同）             |

##### 2.什么是同源策略

同源策略 (英文全称Same origin policy) 是**浏览器**提供的一个**安全功能**。

MDN 官方给定的概念：同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。

通俗的理解：浏览器规定，A 网站的JavaScript，不允许和非同源的网站C 之间，进行资源的交互，例如：
①无法读取非同源网页的Cookie、LocalStorage和IndexedDB
②无法接触非同源网页的DOM
③无法向非同源地址发送Ajax 请求

#### 1.2 跨域

##### 1.什么是跨域

同源指的是两个URL 的协议、域名、端口一致，反之，则是跨域。

出现跨域的根本原因：浏览器的同源策略不允许非同源的URL 之间进行资源的交互。

网页：http://www.test.com/index.html
接口：http://www.api.com/userlist

##### 2.浏览器对跨域请求的拦截

![image-20211126150558941](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211126150558941.png)

注意：浏览器允许发起跨域请求，但是，跨域请求回来的数据，会被浏览器拦截，无法被页面获取到！

##### 3.如何实现跨域数据请求

现如今，实现跨域数据请求，最主要的两种解决方案，分别是**JSONP**和**CORS**。

JSONP：出现的早，兼容性好 (兼容低版本IE) 。是前端程序员为了解决跨域问题，被迫想出来的一种临时解决方案。缺点是只支持GET 请求，不支持POST 请求。

CORS：出现的较晚，它是W3C 标准，属于跨域Ajax 请求的根本解决方案。支持GET 和POST 请求。缺点是不兼容某些低版本的浏览器。

### 2.JSONP

#### 2.1 什么是JSONP

JSONP (JSON with Padding) 是JSON 的一种“使用模式”，可用于解决主流浏览器的跨域数据访问的问题。

#### 2.2 JSONP的实现原理

由于浏览器同源策略的限制，网页中无法通过Ajax 请求非同源的接口数据。但是 `<script>` 标签不受浏览器同源策略的影响，可以通过src 属性，请求非同源的js 脚本。

因此，JSONP 的实现原理，就是通过 `<script>` 标签的src 属性，请求跨域的数据接口，并通过函数调用的形式，接收跨域接口响应回来的数据。

#### 2.3 自己实现一个简单的JSONP

定义一个success 回调函数：

```html
<script>
  function success(data) {
    console.log('获取到了data数据：')
    console.log(data)
  }
</script>
```

通过 `<script>` 标签，请求接口数据：

```html 
<script src="http://ajax.frontend.itheima.net:3006/api/jsonp?callback=success&name=zs&age=20"></script>
```

#### 2.4 JSONP的缺点

由于JSONP 是通过 `<script>` 标签的src 属性，来实现跨域数据获取的，所以，JSONP 只支持GET 数据请求，不支持POST 请求。

注意：JSONP 和Ajax 之间没有任何关系，不能把JSONP 请求数据的方式叫做Ajax，因为JSONP 没有用到XMLHttpRequest 这个对象。

#### 2.5 jQuery中的JSONP

jQuery 提供的 `$.ajax()` 函数，除了可以发起真正的Ajax 数据请求之外，还能够发起JSONP 数据请求，例如：

```javascript
$.ajax({
  url: 'http://ajax.frontend.itheima.net:3006/api/jsonp?name=zs&age=20',
  // 如果要使用$.ajax()发起JSONP请求，必须指定datatype为jsonp
  dataType: 'jsonp',
  success: function (res) {
    console.log(res)
  },
})
```

默认情况下，使用jQuery 发起JSONP 请求，会自动携带一个callback=jQueryxxx的参数，jQueryxxx是随机生成的一个回调函数名称。

#### 2.6 自定义参数及回调函数名称

在使用jQuery 发起JSONP 请求时，如果想要自定义JSONP 的参数以及回调函数名称，可以通过如下两个参数来指定：

```javascript
$.ajax({
  url: 'http://ajax.frontend.itheima.net:3006/api/jsonp?name=zs&age=20',
  dataType: 'jsonp',
  // 发送到服务端的参数名称，默认值为callback
  jsonp: 'callback',
  // 自定义的回调函数名称，默认值为jQueryxxx格式
  jsonpCallback: 'abc',
  success: function (res) {
    console.log(res)
  },
})
```

#### 2.7 jQuery中JSONP的实现过程

jQuery 中的JSONP，也是通过 `<script>` 标签的src属性实现跨域数据访问的，只不过，jQuery 采用的是动态创建和移除 `<script>` 标签的方式，来发起JSONP 数据请求。

- 在发起JSONP 请求的时候，动态向 `<header>` 中append 一个 `<script>` 标签；
- 在JSONP 请求成功以后，动态从 `<header>` 中移除刚才append 进去的 `<script>` 标签；

### 3.案例–淘宝搜索

#### 3.1 要实现的UI效果

![image-20211126153453924](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211126153453924.png)

#### 3.2 获取用户输入的搜索关键词

为了获取到用户每次按下键盘输入的内容，需要监听输入框的keyup事件，示例代码如下：

```javascript
// 监听文本框的keyup事件
$('#ipt').on('keyup', function () {
  // 获取用户输入的内容
  varkeywords = $(this).val().trim()
  // 判断用户输入的内容是否为空
  if (keywords.length <= 0) {
    return
  }
  // TODO：获取搜索建议列表
})
```

#### 3.3 封装getSuggestList函数

将获取搜索建议列表的代码，封装到getSuggestList函数中，示例代码如下：

```javascript
function getSuggestList(kw) {
  $.ajax({
    // 指定请求的URL地址，其中，q是用户输入的关键字
    url: 'https://suggest.taobao.com/sug?q=' + kw,
    //指定要发起的是JSONP请求
    dataType: 'jsonp',
    // 成功的回调函数
    success: function (res) {
      console.log(res)
    },
  })
}
```

#### 3.4 渲染建议列表的UI结构

##### 1.定义搜索建议列表

```html
<div class="box">
  <!--tab栏区域-->
  <div class="tabs"></div>
  <!--搜索区域-->
  <div class="search-box"></div>

  <!--搜索建议列表-->
  <div id="suggest-list"></div>
</div>
```

##### 2.定义模板结构

```html
<!--模板结构-->
<script type="text/html" id="tpl-suggestList">
  {{eachresult}}
    <div class="suggest-item">{{$value[0]}}</div>
  {{/each}}
</script>
```

##### 3.定义渲染模板结构的函数

```javascript
// 渲染建议列表
function renderSuggestList(res) {
  // 如果没有需要渲染的数据，则直接return
  if (res.result.length <= 0) {
    return $('#suggest-list').empty().hide()
  }
  // 渲染模板结构
  var htmlStr = template('tpl-suggestList', res)
  $('#suggest-list').html(htmlStr).show()
}
```

##### 4.搜索关键词为空时隐藏搜索建议列表

```javascript
$('#ipt').on('keyup', function () {
  //获取用户输入的内容
  varkeywords = $(this).val().trim()
  //判断用户输入的内容是否为空
  if (keywords.length <= 0) {
    // 如果关键词为空，则清空后隐藏搜索建议列表
    return$('#suggest-list').empty().hide()
  }
  getSuggestList(keywords)
})
```

#### 3.5 输入框的防抖

##### 1.什么是防抖

防抖策略（debounce）是当事件被触发后，延迟n 秒后再执行回调，如果在这n 秒内事件又被触发，则重新计时。

![image-20211126210847061](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211126210847061.png)

##### 2.防抖的应用场景

用户在输入框中连续输入一串字符时，可以通过防抖策略，只在输入完后，才执行查询的请求，这样可以有效减少请求次数，节约请求资源；

##### 3.实现输入框的防抖

```javascript
var timer = null // 1. 防抖动的timer

function debounceSearch(keywords) {
  // 2. 定义防抖的函数
  timer = setTimeout(function () {
    // 发起JSONP请求
    getSuggestList(keywords)
  }, 500)
}

$('#ipt').on('keyup', function () {
  // 3. 在触发keyup事件时，立即清空timer
  clearTimeout(timer)
  // ...省略其他代码
  debounceSearch(keywords)
})
```

#### 3.6 缓存搜索的建议列表

##### 1.定义全局缓存对象

```javascript
// 缓存对象
var cacheObj = {}
```

##### 2.将搜索结果保存到缓存对象中

```javascript
// 渲染建议列表
function renderSuggestList(res) {
  // ...省略其他代码
  // 将搜索的结果，添加到缓存对象中
  vark = $('#ipt').val().trim()
  cacheObj[k] = res
}
```

##### 3.优先从缓存中获取搜索建议

```javascript
// 监听文本框的keyup事件
$('#ipt').on('keyup', function () {
  // ...省略其他代码
  // 优先从缓存中获取搜索建议
  if (cacheObj[keywords]) {
    returnrenderSuggestList(cacheObj[keywords])
  }
  //获取搜索建议列表
  debounceSearch(keywords)
})
```

### 4.防抖和节流

#### 4.1 什么是节流

节流策略 (throttle)，顾名思义，可以减少一段时间内事件的触发频率。

![image-20211126210806795](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211126210806795.png)

#### 4.2 节流的应用场景

①鼠标连续不断地触发某事件 (如点击)，只在单位时间内只触发一次；
②懒加载时要监听计算滚动条的位置，但不必每次滑动都触发，可以降低计算的频率，而不必去浪费CPU 资源；

#### 4.3 节流案例–鼠标跟随效果

![image-20211126211017399](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211126211017399.png)

##### 1.渲染UI结构并美化样式

```html
<!-- UI结构 -->
<img src="./assets/angel.gif" alt="" id="angel" />
```

```css
/* CSS样式 */
html,
body {
  margin: 0;
  padding: 0;
  overflow: hidden;
}
#angel {
  position: absolute;
}
```

##### 2.不使用节流时实现鼠标跟随效果

```javascript
$(function () {
  // 获取图片元素
  var angel = $('#angel')
  // 监听文档的mousemove事件
  $(document).on('mousemove', function (e) {
    // 设置图片的位置
    $(angel)
      .css('left', e.pageX + 'px')
      .css('top', e.pageY + 'px')
  })
})
```

##### 3.节流阀的概念

高铁卫生间是否被占用，由红绿灯控制，红灯表示被占用，绿灯表示可使用。

假设每个人上卫生间都需要花费5分钟，则五分钟之内，被占用的卫生间无法被其他人使用。

上一个人使用完毕后，需要将红灯重置为绿灯，表示下一个人可以使用卫生间。

下一个人在上卫生间之前，需要先判断控制灯是否为绿色，来知晓能否上卫生间。

<hr />

节流阀为空，表示可以执行下次操作；不为空，表示不能执行下次操作。

当前操作执行完，必须将节流阀重置为空，表示可以执行下次操作了。

每次执行操作前，必须先判断节流阀是否为空。

##### 4.使用节流优化鼠标跟随效果

```javascript
$(function () {
  var angel = $('#angel')
  var timer = null //1.预定义一个timer节流阀
  $(document).on('mousemove', function (e) {
    if (timer) {
      return
    } // 3.判断节流阀是否为空，如果不为空，则证明距离上次执行间隔不足16毫秒
    timer = setTimeout(function () {
      $(angel)
        .css('left', e.pageX + 'px')
        .css('top', e.pageY + 'px')
      timer = null // 2.当设置了鼠标跟随效果后，清空timer 节流阀，方便下次开启延时器
    }, 16)
  })
})
```

#### 4.4 总结防抖和节流的区别

- 防抖：如果事件被频繁触发，防抖能保证只有最有一次触发生效！前面N 多次的触发都会被忽略！
- 节流：如果事件被频繁触发，节流能够减少事件触发的频率，因此，节流是有选择性地执行一部分事件！

## 五、HTTP协议加强

### 1.HTTP协议简介

#### 1.1 什么是通信

通信，就是信息的传递和交换。

通信三要素：

- 通信的 **主体**
- 通信的 **内容**
- 通信的 **方式**

##### 1.现实生活中的通信

案例：张三要把自己考上传智专修学院的好消息写信告诉自己的好朋友李四。

其中：
通信的主体是张三和李四；
通信的内容是考上传智专修学院；
通信的方式是写信；

##### 2.互联网中的通信

案例：服务器把传智专修学院的简介通过响应的方式发送给客户端浏览器。

其中，
通信的主体是服务器和客户端浏览器；
通信的内容是传智专修学院的简介；
通信的方式是响应；

#### 1.2 什么是通信协议

通信协议 (Communication Protocol) 是指通信的双方完成通信所必须遵守的规则和约定。

通俗的理解：通信双方采用约定好的格式来发送和接收消息，这种事先约定好的通信格式，就叫做通信协议。

##### 1.现实生活中的通信协议

张三与李四采用写信的方式进行通信，在填写信封时，写信的双方需要遵守固定的规则。信封的填写规则就是一种通信协议。

![image-20211126213439235](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211126213439235.png)

##### 2.互联网中的通信协议

客户端与服务器之间要实现网页内容的传输，则通信的双方必须遵守网页内容的传输协议。

**网页内容**又叫做**超文本**，因此**网页内容的传输协议**又叫做**超文本传输协议** (HyperText Transfer Protocol)，简称 **HTTP 协议**。

#### 1.3 HTTP

##### 1.什么是HTTP协议

HTTP 协议即超文本传送协议(**H**yper**T**ext **T**ransfer **P**rotocol) ，它规定了客户端与服务器之间进行网页内容传输时，所必须遵守的传输格式。

例如：

- 客户端要以HTTP协议要求的格式把数据提交到服务器
- 服务器要以HTTP协议要求的格式把内容响应给客户端

##### 2.HTTP协议的交互模型

HTTP 协议采用了请求/响应的交互模型。

![image-20211126213900257](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211126213900257.png)

### 2.HTTP请求消息

#### 2.1 什么是HTTP请求消息

由于HTTP 协议属于客户端浏览器和服务器之间的通信协议。因此，客户端发起的请求叫做HTTP 请求，客户端发送到服务器的消息，叫做HTTP 请求消息。

注意：HTTP 请求消息又叫做HTTP 请求报文。

#### 2.2 HTTP请求消息的组成部分

HTTP 请求消息由请求行 (request line)、请求头部 (header)、空行和请求体4 个部分组成。

![image-20211126214140771](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211126214140771.png)

##### 1.请求行

请求行由请求方式、URL和HTTP 协议版本3 个部分组成，他们之间使用空格隔开。

![image-20211126214254529](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211126214254529.png)

##### 2.请求头部

请求头部用来描述客户端的基本信息，从而把客户端相关的信息告知服务器。

比如：
User-Agent用来说明当前是什么类型的浏览器；
Content-Type用来描述发送到服务器的数据格式；
Accept用来描述客户端能够接收什么类型的返回内容；
Accept-Language用来描述客户端期望接收哪种人类语言的文本内容。

请求头部由多行键/值对组成，每行的键和值之间用英文的冒号分隔。

![image-20211126214616347](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211126214616347.png)

##### 2.请求头部–常见的请求头字段

| 头部字段            | 说明                                        |
| ------------------- | ------------------------------------------- |
| Host                | 要请求的服务器域名                          |
| Connection          | 客户端与服务器的连接方式(close 或keepalive) |
| Content-Length      | 用来描述请求体的大小                        |
| **Accept**          | 客户端可识别的响应内容类型列表              |
| **User-Agent**      | 产生请求的浏览器类型                        |
| **Content-Type**    | 客户端告诉服务器实际发送的数据类型          |
| Accept-Encoding     | 客户端可接收的内容压缩编码形式              |
| **Accept-Language** | 用户期望获得的自然语言的优先顺序            |


![image-20211126214917914](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211126214917914.png)


关于更多请求头字段的描述，可以查看MDN 官方文档：https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers

##### 3.空行

最后一个请求头字段的后面是一个空行，通知服务器请求头部至此结束。

请求消息中的空行，用来分隔请求头部与请求体。

![image-20211126215104215](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211126215104215.png)

##### 4.请求体

请求体中存放的，是要通过POST 方式提交到服务器的数据。

![image-20211126215156510](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211126215156510.png)


注意：只有POST 请求才有请求体，GET 请求没有请求体！

##### 5.总结

![image-20211126214140771](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211126214140771.png)

### 3.HTTP响应消息

#### 3.1 什么是HTTP响应消息

响应消息就是服务器响应给客户端的消息内容，也叫作响应报文。

#### 3.2 HTTP响应消息的组成部分

HTTP响应消息由状态行、响应头部、空行和响应体4 个部分组成，如下图所示：

![image-20211126215618669](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211126215618669.png)

##### 1.状态行

状态行由HTTP 协议版本、状态码和状态码的描述文本3 个部分组成，他们之间使用空格隔开；

![image-20211126215804829](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211126215804829.png)

##### 2.响应头部

响应头部用来描述服务器的基本信息。响应头部由多行键/值对组成，每行的键和值之间用英文的冒号分隔。

![image-20211126215938624](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211126215938624.png)

##### 2.响应头部–常见的响应头字段

![image-20211126220033491](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211126220033491.png)

关于更多响应头字段的描述，可以查看MDN 官方文档：https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers

##### 3.空行

在最后一个响应头部字段结束之后，会紧跟一个空行，用来通知客户端响应头部至此结束。

响应消息中的空行，用来分隔响应头部与响应体。

![image-20211126220135504](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211126220135504.png)

##### 4.响应体

响应体中存放的，是服务器响应给客户端的资源内容。

![image-20211126220259525](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211126220259525.png)

##### 5.总结

![image-20211126215618669](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211126215618669.png)

### 4.HTTP请求方法

#### 4.1 什么是HTTP请求方法

HTTP 请求方法，属于HTTP 协议中的一部分，请求方法的作用是：用来表明要对服务器上的资源执行的操作。最常用的请求方法是GET 和POST。

#### 4.2 HTTP的请求方法

| 序号 | 方法       | 描述                                                         |
| ---- | ---------- | ------------------------------------------------------------ |
| 1    | **GET**    | **(查询)**发送请求来获得服务器上的资源，请求体中不会包含请求数据，请求数据放在协议头中。 |
| 2    | **POST**   | **(新增)**向服务器提交资源（例如提交表单或上传文件）。数据被包含在请求体中提交给服务器。 |
| 3    | **PUT**    | **(修改)**向服务器提交资源，并使用提交的新资源，替换掉服务器对应的旧资源。 |
| 4    | **DELETE** | **(删除)**请求服务器删除指定的资源。                         |
| 5    | HEAD       | HEAD 方法请求一个与GET 请求的响应相同的响应，但没有响应体。  |
| 6    | OPTIONS    | 获取http服务器支持的http请求方法，允许客户端查看服务器的性能，比如ajax跨域时的预检等。 |
| 7    | CONNECT    | 建立一个到由目标资源标识的服务器的隧道。                     |
| 8    | TRACE      | 沿着到目标资源的路径执行一个消息环回测试，主要用于测试或诊断。 |
| 9    | PATCH      | 是对PUT 方法的补充，用来对已知资源进行局部更新。             |

### 5.HTTP响应状态码

#### 5.1 什么是HTTP响应状态码

HTTP 响应状态码 (HTTP Status Code)，也属于HTTP 协议的一部分，用来标识响应的状态。

响应状态码会随着响应消息一起被发送至客户端浏览器，浏览器根据服务器返回的响应状态码，就能知道这次HTTP 请求的结果是成功还是失败了。

![image-20211126220857161](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211126220857161.png)

#### 5.2 HTTP响应状态码的组成及分类

HTTP 状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字用来对状态码进行细分。

HTTP 状态码共分为5 种类型：

| 分类 | 分类描述                                                     |
| ---- | ------------------------------------------------------------ |
| 1**  | 信息，服务器收到请求，需要请求者继续执行操作（实际开发中很少遇到1** 类型的状态码） |
| 2**  | 成功，操作被成功接收并处理                                   |
| 3**  | 重定向，需要进一步的操作以完成请求                           |
| 4**  | 客户端错误，请求包含语法错误或无法完成请求                   |
| 5**  | 服务器错误，服务器在处理请求的过程中发生了错误               |

完整的HTTP 响应状态码，可以参考MDN 官方文档https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status

#### 5.3 常见的HTTP响应状态码

##### 1.2** 成功相关的响应状态码

2** 范围的状态码，表示服务器已成功接收到请求并进行处理。常见的2** 类型的状态码如下：

| 状态码 | 状态码英文名称 | 中文描述                                                  |
| ------ | -------------- | --------------------------------------------------------- |
| 200    | OK             | 请求成功。一般用于GET 与POST 请求                         |
| 201    | Created        | 已创建。成功请求并创建了新的资源，通常用于POST 或PUT 请求 |

##### 2.3** 重定向相关的响应状态码

3** 范围的状态码，表示表示服务器要求客户端重定向，需要客户端进一步的操作以完成资源的请求。常见的3** 类型的状态码如下：

| 状态码 | 状态码英文名称    | 中文描述                                                     |
| ------ | ----------------- | ------------------------------------------------------------ |
| 301    | Moved Permanently | 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 |
| 302    | Found             | 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI |
| 304    | Not Modified      | 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源（响应消息中不包含响应体）。客户端通常会缓存访问过的资源。 |

##### 3.4** 客户端错误相关的响应状态码

4** 范围的状态码，表示客户端的请求有非法内容，从而导致这次请求失败。常见的4** 类型的状态码如下：

| 状态码  | 状态码英文名称  | 中文描述                                                     |
| ------- | --------------- | ------------------------------------------------------------ |
| 400     | Bad Request     | 1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。<br/>2、请求参数有误。 |
| 401     | Unauthorized    | 当前请求需要用户验证。                                       |
| 403     | Forbidden       | 服务器已经理解请求，但是拒绝执行它。                         |
| **404** | **Not Found**   | **服务器无法根据客户端的请求找到资源 (网页)。**              |
| 408     | Request Timeout | 请求超时。服务器等待客户端发送的请求时间过长，超时。         |

##### 4.5** 服务端错误相关的响应状态码

5** 范围的状态码，表示服务器未能正常处理客户端的请求而出现意外错误。常见的5** 类型的状态码如下：

| 状态码 | 状态码英文名称        | 中文描述                                                     |
| ------ | --------------------- | ------------------------------------------------------------ |
| 500    | Internal Server Error | 服务器内部错误，无法完成请求。                               |
| 501    | Not Implemented       | 服务器不支持该请求方法，无法完成请求。只有GET 和HEAD 请求方法是要求每个服务器必须支持的，其它请求方法在不支持的服务器上会返回501 |
| 503    | Service Unavailable   | 由于超载或系统维护，服务器暂时的无法处理客户端的请求。       |

## 六、Git

### 1.起步-关于版本控制

#### 1.文件的版本

![image-20211126222322870](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211126222322870.png)

- 操作麻烦
  每次都需要复制→粘贴→重命名

- 命名不规范
  无法通过文件名知道具体做了哪些修改

- 容易丢失
  如果硬盘故障或不小心删除，文件很容易丢失

- 协作困难
  需要手动合并每个人对项目文件的修改，合并时极易出错

人和动物的区别？
人会制造并使用工具

#### 2.版本控制软件

概念：版本控制软件是一个用来记录文件变化，以便将来查阅特定版本修订情况的系统，因此有时也叫做“版本控制系统”。

通俗的理解：把手工管理文件版本的方式，改为由软件管理文件的版本；这个负责管理文件版本的软件，叫做“版本控制软件”。

#### 3.使用版本控制软件的好处

- 操作简便
  只需识记几组简单的终端命令，即可快速上手常见的版本控制软件

- 易于对比
  基于版本控制软件提供的功能，能够方便地比较文件的变化细节，从而查找出导致问题的原因

- 易于回溯
  可以将选定的文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态

- 不易丢失
  在版本控制软件中，被用户误删除的文件，可以轻松的恢复回来

- 协作方便
  基于版本控制软件提供的分支功能，可以轻松实现多人协作开发时的代码合并操作

#### 4.版本控制系统的分类


本地版本控制系统：单机运行，使维护文件版本的操作工具化。

集中化的版本控制系统：联网运行，支持多人协作开发；性能差、用户体验不好。

分布式版本控制系统：联网运行，支持多人协作开发；性能优秀、用户体验好。

##### 4.1 本地版本控制系统

本地版本控制图解

![image-20211126223121750](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211126223121750.png)

特点：
使用软件来记录文件的不同版本，提高了工作效率，降低了手动维护版本的出错率

缺点：
①单机运行，不支持多人协作开发
②版本数据库故障后，所有历史更新记录会丢失

##### 4.2 集中化的版本控制系统

典型代表：SVN

![image-20211126223235429](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211126223235429.png)

特点：
基于服务器、客户端的运行模式
①服务器保存文件的所有更新记录
②客户端只保留最新的文件版本

优点：
联网运行，支持多人协作开发

缺点：
①不支持离线提交版本更新
②中心服务器崩溃后，所有人无法正常工作
③版本数据库故障后，所有历史更新记录会丢失

##### 4.3 分布式版本控制系统

典型代表：Git

![image-20211126223355828](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211126223355828.png)

特点：基于服务器、客户端的运行模式
①服务器保存文件的所有更新版本
②客户端是服务器的完整备份，并不是只保留文件的最新版本

优点：
①联网运行，支持多人协作开发
②客户端断网后支持离线本地提交版本更新
③服务器故障或损坏后，可使用任何一个客户端的备份进行恢复

### 1.起步-Git 基础

#### 1.什么是Git

Git 是一个开源的分布式版本控制系统，是目前世界上最先进、最流行的版本控制系统。可以快速高效地处理从很小到非常大的项目版本管理。

特点：项目越大越复杂，协同开发者越多，越能体现出Git 的高性能和高可用性！

#### 2.Git 的特性

Git 之所以快速和高效，主要依赖于它的如下两个特性：
①直接记录快照，而非差异比较
②近乎所有操作都是本地执行

##### 2.1 SVN 的差异比较

传统的版本控制系统 (例如SVN) 是基于差异的版本控制，它们存储的是一组基本文件和每个文件随时间逐步累积的差异。

![image-20211126223743849](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211126223743849.png)

好处：节省磁盘空间
缺点：耗时、效率低

在每次切换版本的时候，都需要在基本文件的基础上，应用每个差异，从而生成目标版本对应的文件。

##### 2.2 Git 的记录快照

Git 快照是在原有文件版本的基础上重新生成一份新的文件，类似于备份。为了效率，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。

![image-20211126223949781](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211126223949781.png)
缺点：占用磁盘空间较大
优点：版本切换时非常快，因为每个版本都是完整的文件快照，切换版本时直接恢复目标版本的快照即可。

特点：空间换时间

##### 2.3 近乎所有操作都是本地执行

![image-20211126223355828](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211126223355828.png)

在Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。

特性：
①断网后依旧可以在本地对项目进行版本管理
②联网后，把本地修改的记录同步到云端服务器即可

#### 3.Git 中的三个区域

使用Git 管理的项目，拥有三个区域，分别是工作区、暂存区、Git 仓库。

- 工作区
  处理工作的区域

- 暂存区
  已完成的工作的临时存放区域，等待被提交

- Git 仓库
  最终的存放区域

#### 4.Git 中的三种状态

- 已修改modified
  表示修改了文件，但还没将修改的结果放到暂存区

- 已暂存staged
  表示对已修改文件的当前版本做了标记，使之包含在下次提交的列表中

- 已提交committed
  表示文件已经安全地保存在本地的Git 仓库中

注意：

- 工作区的文件被修改了，但还没有放到暂存区，就是已修改状态。
- 如果文件已修改并放入暂存区，就属于已暂存状态。
- 如果Git 仓库中保存着特定版本的文件，就属于已提交状态。

#### 5.基本的Git 工作流程

![image-20211126224736565](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211126224736565.png)

基本的Git 工作流程如下：
①在工作区中修改文件
②将你想要下次提交的更改进行暂存
③提交更新，找到暂存区的文件，将快照永久性存储到Git 仓库

### 2.Git 基础-安装并配置Git

#### 1.在Windows 中下载并安装Git

在开始使用Git 管理项目的版本之前，需要将它安装到计算机上。可以使用浏览器访问如下的网址，根据自己的操作系统，选择下载对应的Git 安装包：

https://git-scm.com/downloads

#### 2.配置用户信息

安装完Git 之后，要做的第一件事就是设置自己的用户名和邮件地址。因为通过Git 对项目进行版本管理的时候，Git 需要使用这些基本信息，来记录是谁对项目进行了操作：

```
git config --global user.name "itheima"
git config --global user.email "itheima@itcast.cn"
```


注意：如果使用了 `--global` 选项，那么该命令只需要运行一次，即可永久生效。

#### 3.Git 的全局配置文件

通过 `git config --global user.name` 和 `git config --global user.email` 配置的用户名和邮箱地址，会被写入到 `C:/Users/用户名文件夹/.gitconfig` 文件中。这个文件是Git 的全局配置文件，配置一次即可永久生效。

可以使用记事本打开此文件，从而查看自己曾经对Git 做了哪些全局性的配置。

#### 4.检查配置信息

除了使用记事本查看全局的配置信息之外，还可以运行如下的终端命令，快速的查看Git 的全局配置信息：

``` 
# 查看所有的全局配置项
git config --list --global
# 查看指定的全局配置项
git config user.name
git config user.email
```

#### 5.获取帮助信息

可以使用 `git help <verb>` 命令，无需联网即可在浏览器中打开帮助手册，例如：

```
# 要想打开 git config 命令的帮助手册
git help config
```

如果不想查看完整的手册，那么可以用 `-h` 选项获得更简明的“help”输出：

```
# 想要获取 git config 命令的快速参考
git config -h
```

### 2.Git 基础-Git的基本操作

> 注：ctrl+l或者直接输入clear都可以清空 git bash 的终端命令框。

#### 1.获取Git仓库的两种方式

①将尚未进行版本控制的本地目录转换为Git 仓库
②从其它服务器克隆一个已存在的Git 仓库


以上两种方式都能够在自己的电脑上得到一个可用的Git 仓库

#### 2.在现有目录中初始化仓库

如果自己有一个尚未进行版本控制的项目目录，想要用Git 来控制它，需要执行如下两个步骤：
①在项目目录中，通过鼠标右键打开“Git Bash”
②执行 `git init` 命令将当前的目录转化为Git 仓库

`git init` 命令会创建一个名为 `.git` 的隐藏目录，这个 `.git` 目录就是当前项目的Git 仓库，里面包含了初始的必要文件，这些文件是Git 仓库的必要组成部分。

#### 3.工作区中文件的4种状态

工作区中的每一个文件可能有4 种状态，这四种状态共分为两大类，如图所示：

![image-20211127104528947](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211127104528947.png)

Git 操作的终极结果：让工作区中的文件都处于“未修改”的状态。

#### 4.检查文件的状态

可以使用 `git status` 命令查看文件处于什么状态，例如：

![image-20211127104723825](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211127104723825.png)

在状态报告中可以看到新建的index.html 文件出现在Untracked files（未跟踪的文件）下面。

未跟踪的文件意味着Git 在之前的快照 (提交) 中没有这些文件；Git 不会自动将之纳入跟踪范围，除非明确地告诉它“我需要使用Git 跟踪管理该文件”。

#### 5.以精简的方式显示文件状态

使用 `git status` 输出的状态报告很详细，但有些繁琐。如果希望以精简的方式显示文件的状态，可以使用如下两条完全等价的命令，其中 `-s` 是 `--short` 的简写形式：

```
# 以精简的方式显示文件状态
git status -s
git status --short
```


未跟踪文件前面有红色的 ?? 标记，例如：

![image-20211127105052703](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211127105052703.png)

#### 6.跟踪新文件

使用命令 `git add` 开始跟踪一个文件。所以，要跟踪index.html 文件，运行如下的命令即可：

```
git add index.html
```


此时再运行 `git status` 命令，会看到index.html 文件在Changes to be committed 这行的下面，说明已被跟踪，并处于暂存状态：

![image-20211127105309581](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211127105309581.png)

以精简的方式显示文件的状态：新添加到暂存区中的文件前面有绿色的A标记

![image-20211127105327617](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211127105327617.png)

#### 7.提交更新

现在暂存区中有一个index.html 文件等待被提交到Git 仓库中进行保存。可以执行 `git commit` 命令进行提交，其中 `-m` 选项后面是本次的提交消息，用来对提交的内容做进一步的描述：

```
git commit -m "新建了index.html"
```

提交成功之后，会显示如下的信息：

![image-20211127105603227](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211127105603227.png)

提交成功之后，再次检查文件的状态，得到提示如下：

![image-20211127105819398](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211127105819398.png)

证明工作区中所有的文件都处于“未修改”的状态，没有任何文件需要被提交。

![image-20211127105915329](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211127105915329.png)

#### 8.对已提交的文件进行修改

目前，index.html 文件已经被Git 跟踪，并且工作区和Git 仓库中的index.html 文件内容保持一致。当我们修改了工作区中index.html 的内容之后，再次运行 `git status` 和 `git status -s` 命令，会看到如下的内容：

![image-20211127110110233](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211127110110233.png)


文件index.html 出现在Changes not staged for commit这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。

注意：修改过的、没有放入暂存区的文件前面有红色的M 标记。

#### 9.暂存已修改的文件

目前，工作区中的index.html 文件已被修改，如果要暂存这次修改，需要再次运行 `git add` 命令，这个命令是个多功能的命令，主要有如下3 个功效：

①可以用它开始跟踪新文件
②把已跟踪的、且已修改的文件放到暂存区
③把有冲突的文件标记为已解决状态

![image-20211127110418862](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211127110418862.png)

#### 10.提交已暂存的文件

再次运行 `git commit -m` "提交消息" 命令，即可将暂存区中记录的index.html的快照，提交到Git 仓库中进行保存：

![image-20211127110645778](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211127110645778.png)

![image-20211127110847203](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211127110847203.png)

#### 11.撤销对文件的修改

撤销对文件的修改指的是：把对工作区中对应文件的修改，还原成Git 仓库中所保存的版本。

```
git checkout -- index.html
```

操作的结果：所有的修改会丢失，且**无法恢复**！**危险性比较高，请慎重操作**！

![image-20211127110934781](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211127110934781.png)


撤销操作的本质：用Git 仓库中保存的文件，覆盖工作区中指定的文件。

#### 12.向暂存区中一次性添加多个文件

如果需要被暂存的文件个数比较多，可以使用如下的命令，一次性将所有的新增和修改过的文件加入暂存区：

```
git add .
```


今后在项目开发中，会经常使用这个命令，将新增和修改过后的文件加入暂存区。

#### 13.取消暂存的文件

如果需要从暂存区中移除对应的文件，可以使用如下的命令：

```
git reset HEAD 要移除的文件名称
```

#### 14.跳过使用暂存区域

Git 标准的工作流程是 `工作区 → 暂存区 → Git 仓库`，但有时候这么做略显繁琐，此时可以跳过暂存区，直接将工作区中的修改提交到Git 仓库，这时候Git 工作的流程简化为了 `工作区 → Git 仓库`。

Git 提供了一个跳过使用暂存区域的方式，只要在提交的时候，给 `git commit 加上-a` 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 `git add` 步骤：

```
git commit -a -m "描述信息"
```

#### 15.移除文件

从Git 仓库中移除文件的方式有两种：
①从Git仓库和工作区中同时移除对应的文件
②只从Git仓库中移除指定的文件，但保留工作区中对应的文件

```
# 从 Git 仓库和工作区中同时移除 index.js 文件
git rm -f index.js
# 只从 Git 仓库中移除 index.css 文件，但保留工作区中 index.css 文件
git rm --cached index.css
```

#### 16.忽略文件

一般我们总会有些文件无需纳入Git 的管理，也不希望它们总出现在未跟踪文件列表。在这种情况下，我们可以创建一个名为 `.gitignore` 的配置文件，列出要忽略的文件的匹配模式。

文件.gitignore 的格式规范如下：
①以 # 开头的是注释
②以 / 结尾的是目录
③以 / 开头防止递归
④以 ! 开头表示取反
⑤可以使用glob 模式进行文件和文件夹的匹配 (glob 指简化了的正则表达式)

#### 17.glob 模式

所谓的glob 模式是指简化了的正则表达式：
①星号 * 匹配零个或多个任意字符
②[abc] 匹配任何一个列在方括号中的字符（此案例匹配一个a或匹配一个b 或匹配一个c）
③问号 ? 只匹配一个任意字符
④在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如[0-9] 表示匹配所有0 到9 的数字）
⑤两个星号 ** 表示匹配任意中间目录（比如a/**/z 可以匹配a/z 、a/b/z 或a/b/c/z 等）

#### 18. .gitignore 文件的例子

```
# 忽略所有的 .a 文件
*.a

# 但跟踪所有的 lib.a ，即便你在前面忽略了 .a 文件
!lib.a

# 只忽略当前目录下的 TODO 文件，而不忽略 subdir/TODO
/TOD0

#忽略任何目录下名为 build 的文件夹
build/

#忽略 doc/notes.txt ，但不忽略 doc/server/arch.txt
doc/*.txt

#忽略 doc/目录及其所有子目录下的 .pdf 文件
doc/**/*.pdf
```

#### 19.查看提交历史

如果希望回顾项目的提交历史，可以使用git log 这个简单且有效的命令。

```
# 按时间先后顺序列出所有的提交历史，最近的提交排在最上面
git log

# 只展示最新的两条提交历史，数字可以按需进行填写
git log -2

# 在一行上展示最近两条提交历史的信息
git log -2 --pretty=oneline

# 在一行上展示最近两条提交历史的信息，并自定义输出的格式
# %h 提交的简写哈希值   %an作者名字   %ar作者修订日期，按多久以前的方式显示   %s提交说明
git log -2--pretty=format:"%h | %an | %ar | %s"
```

#### 20.回退到指定的版本

```
# 在一行上展示所有的提交历史
git log --pretty=oneline

# 使用 git reset --hard 命令，根据指定的提交ID回退到指定版本
git reset --hard <CommitID>

# 在旧版本中使用 git reflog --pretty=oneline 命令，查看命令操作的历史
git reflog --pretty=oneline

# 再次根据最新的提交ID，跳转到最新的版本
git reset --hard <CommitID>
```

#### 21.小结

①初始化Git 仓库的命令

- git init

②查看文件状态的命令

- git status 或 git status -s

③一次性将文件加入暂存区的命令

- git add .

④将暂存区的文件提交到Git 仓库的命令

- git commit -m "提交消息"

### 3.Github-了解开源相关的概念

#### 1.什么是开源

![image-20211127115026551](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211127115026551.png)

通俗的理解：
开源是指不仅提供程序还提供程序的源代码
闭源是只提供程序，不提供源代码

#### 2.什么是开源许可协议

开源并不意味着完全没有限制，为了限制使用者的使用范围和保护作者的权利，每个开源项目都应该遵守开源许可协议 (Open Source License)。

#### 3.常见的5 种开源许可协议

①BSD（Berkeley Software Distribution）
②Apache Licence2.0
③**GPL**（GNU General Public License）

- 具有传染性的一种开源协议，不允许修改后和衍生的代码做为闭源的商业软件发布和销售
- 使用GPL 的最著名的软件项目是：Linux

④LGPL（GNU Lesser General Public License）
⑤**MIT**（Massachusetts Institute of Technology, MIT）

- 是目前限制最少的协议，唯一的条件：在修改后的代码或者发行包中，必须包含原作者的许可信息
- 使用MIT 的软件项目有：jquery、Node.js

关于更多开源许可协议的介绍，可以参考博客https://www.runoob.com/w3cnote/open-source-license.html

#### 4.为什么要拥抱开源

开源的核心思想是“我为人人，人人为我”，人们越来越喜欢开源大致是出于以下3 个原因：
①开源给使用者更多的控制权
②开源让学习变得容易
③开源才有真正的安全


开源是软件开发领域的大趋势，拥抱开源就像站在了巨人的肩膀上，不用自己重复造轮子，让开发越来越容易。

#### 5.开源项目托管平台

专门用于免费存放开源项目源代码的网站，叫做开源项目托管平台。目前世界上比较出名的开源项目托管平台主要有以下3 个：

- Github（全球最牛的开源项目托管平台，没有之一）
- Gitlab（对代码私有性支持较好，因此企业用户较多）
- Gitee（又叫做码云，是国产的开源项目托管平台。访问速度快、纯中文界面、使用友好）

注意：以上3 个开源项目托管平台，只能托管以Git 管理的项目源代码，因此，它们的名字都以Git 开头。

#### 6.什么是Github

Github 是全球最大的开源项目托管平台。因为只支持Git 作为唯一的版本控制工具，故名GitHub。

在Github 中，你可以：
①关注自己喜欢的开源项目，为其点赞打call 
②为自己喜欢的开源项目做贡献（Pull Request）
③和开源项目的作者讨论Bug 和提需求（Issues）
④把喜欢的项目复制一份作为自己的项目进行修改（Fork）
⑤创建属于自己的开源项目
⑥etc…


So，**Github ≠ Git**

### 3.Github-注册账号

#### 1.注册Github 账号的流程

①访问Github 的官网首页https://github.com/
②点击“Sign up”按钮跳转到注册页面
③填写可用的用户名、邮箱、密码
④通过点击箭头的形式，将验证图片摆正
⑤点击“Create account”按钮注册新用户
⑥登录到第三步填写的邮箱中，点击激活链接，完成注册

#### 2.激活Github 账号

略

#### 3.完成注册

略

### 3.Github-远程仓库的使用

#### 1.新建空白远程仓库

![image-20211127120321071](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211127120321071.png)

#### 2.新建空白远程仓库成功

![image-20211127120359429](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211127120359429.png)

#### 3.远程仓库的两种访问方式

Github 上的远程仓库，有两种访问方式，分别是HTTPS和SSH。它们的区别是：

①HTTPS：零配置；但是每次访问仓库时，需要重复输入Github 的账号和密码才能访问成功
②SSH：需要进行额外的配置；但是配置成功后，每次访问仓库时，不需重复输入Github 的账号和密码


注意：在实际开发中，**推荐使用SSH 的方式** 访问远程仓库。

#### 4.基于HTTPS 将本地仓库上传到Github

![image-20211127130419237](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211127130419237.png)

##### 将git仓库里面的内容上传到github

第一次上传git仓库的内容使用以下命令：

```
git push -u origin master
```

第二次级以后上传git仓库的内容只需要执行以下命令即可：

```
git push
```

#### 5.SSH key

SSH key 的作用：实现本地仓库和Github 之间免登录的加密数据传输。

SSH key 的好处：免登录身份认证、数据加密传输。

SSH key 由两部分组成，分别是：
①id_rsa（私钥文件，存放于客户端的电脑中即可）
②id_rsa.pub（公钥文件，需要配置到Github 中）

#### 6.生成SSH key

①打开Git Bash
②粘贴如下的命令，并将 `your_email@example.com` 替换为注册Github 账号时填写的邮箱：

```
ssh-keygen -t rsa -b 4096 -C "your_email@example.com"
```


③连续敲击3次回车，即可在 `C:\Users\用户名文件夹\.ssh` 目录中生成id_rsa和id_rsa.pub 两个文件

#### 7.配置SSH key

①使用记事本打开 id_rsa.pub 文件，复制里面的文本内容
②在浏览器中登录Github，点击头像->Settings->SSH and GPG Keys->New SSH key
③将id_rsa.pub 文件中的内容，粘贴到Key 对应的文本框中
④在Title 文本框中任意填写一个名称，来标识这个Key 从何而来

#### 8.检测Github 的SSH key 是否配置成功

打开Git Bash，输入如下的命令并回车执行：

```
ssh -T git@github.com
```

上述的命令执行成功后，可能会看到如下的提示消息：

```
The authenticity of host 'github.com (IP ADDRESS)' can't be established.

RSA key fingerprint is SHA256:nThbg6kXUpJMG17E1IGOCSpRomTxdCARLViKW6ESSY8.

Are you sure you want to continue connecting (yes/no)?
```


输入yes 之后，如果能看到类似于下面的提示消息，证明SSH key 已经配置成功了：

```
Hi username! You've successfully authenticated,but GitHub does not povide shell access.
```

#### 9.基于SSH 将本地仓库上传到Github

方法和上面的方法相同，按照github要求操作即可。

#### 10.将远程仓库克隆到本地

打开Git Bash，输入如下的命令并回车执行：

```
git clone 远程仓库的地址
```

### 4.Git分支-本地分支操作

#### 1.分支的概念

分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。

如果两个平行宇宙互不干扰，那对现在的你也没啥影响。

不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了Git又学会了SVN！

![image-20211128083743104](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211128083743104.png)

#### 2.分支在实际开发中的作用

在进行多人协作开发的时候，为了防止互相干扰，提高协同开发的体验，建议每个开发者都基于分支进行项目功能的开发，例如：

![image-20211128083807718](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211128083807718.png)

#### 3.master 主分支

在初始化本地Git 仓库的时候，Git 默认已经帮我们创建了一个名字叫做master的分支。通常我们把这个master 分支叫做主分支。

![image-20211128083807718](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211128083807718.png)

在实际工作中，master 主分支的作用是：用来保存和记录整个项目已完成的功能代码。

因此，不允许程序员直接在master 分支上修改代码，因为这样做的风险太高，容易导致整个项目崩溃。

#### 4.功能分支

由于程序员不能直接在master 分支上进行功能的开发，所以就有了功能分支的概念。
功能分支指的是专门用来开发新功能的分支，它是临时从master 主分支上分叉出来的，当新功能开发且测试完毕后，最终需要合并到master 主分支上，如图所示：

![image-20211128083919993](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211128083919993.png)

#### 5.查看分支列表

使用如下的命令，可以查看当前Git  仓库中所有的分支列表：

```
git branch
```

运行的结果如下所示：

![image-20211128084009634](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211128084009634.png)

注意：分支名字前面的*号表示当前所处的分支。

#### 6.创建新分支

使用如下的命令，可以基于当前分支，创建一个新的分支，此时，新分支中的代码和当前分支完全一样：

```
git branch 分支名称
```


图示如下：

![image-20211128084129143](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211128084129143.png)

#### 7.切换分支

使用如下的命令，可以切换到指定的分支上进行开发：

```
git checkout login
```

图示如下：

![image-20211128084456998](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211128084456998.png)

#### 8.分支的快速创建和切换

使用如下的命令，可以创建指定名称的新分支，并立即切换到新分支上：

```
# -b 表示创建一个新分支
# checkout 表示切换到刚才新建的分支上
git checkout -b 分支名称
```

图示如下：

![image-20211128084648584](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211128084648584.png)

注意：
"git checkout -b 分支名称" 是下面两条命令的简写形式：
①git branch 分支名称
②git checkout 分支名称

#### 9.合并分支

功能分支的代码开发测试完毕之后，可以使用如下的命令，将完成后的代码合并到master 主分支上：

```
# 1. 切换到 master 分支
git checkout master
# 2. 在 master 分支上运行 git merge 命令，将 login 分支的代码合并到 master 分支
git merge login
```

图示如下：

![image-20211128085109399](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211128085109399.png)

合并分支时的注意点：
假设要把C 分支的代码合并到A 分支，则必须先切换到A 分支上，再运行git merge 命令，来合并C 分支！

#### 9.删除分支

当把功能分支的代码合并到master 主分支上以后，就可以使用如下的命令，删除对应的功能分支：

```
git branch -d 分支名称
```


图示如下：

![image-20211128085211612](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211128085211612.png)

#### 10.遇到冲突时的分支合并

如果在两个不同的分支中，对同一个文件进行了不同的修改，Git 就没法干净的合并它们。此时，我们需要打开这些包含冲突的文件然后手动解决冲突。

```
# 假设：在把 reg 分支合并到 master 分支期间，代码发誓我那个了冲突
git checkout master
git merge reg

# 打开包含冲突的文件，手动解决冲突之后，在执行如下命令
git add .
git commit -m "解决了分支合并的冲突的问题"
```

### 4.Git分支-远程分支操作

> 远程仓库的名称/别名统一为origin即可

#### 1.将本地分支推送到远程仓库

如果是第一次将本地分支推送到远程仓库，需要运行如下的命令：

```
# -u 表示把本地分支和远程分支进行关联，只在第一次推送的时候需要带-U参数
git push -u 远程仓库的别名 本地分支名称:远程分支名称

# 实际案例:
git push -u origin payment:pay

# 如果希望远程分支的名称和本地分支名称保持一致，可以对命令进行简化:
git push -u origin payment

```


注意：第一次推送分支需要带-u 参数，此后可以直接使用git push 推送代码到远程分支。

#### 2.查看远程仓库中所有的分支列表

通过如下的命令，可以查看远程仓库中，所有的分支列表的信息：

```
git remote show 远程仓库名称
```

#### 3.跟踪分支

跟踪分支指的是：从远程仓库中，把远程分支下载到本地仓库中。需要运行的命令如下：

```
# 从远程仓库中，把对应的远程分支下载到本地仓库，保持本地分支和远程分支名称相同
git checkout 远程分支的名称
# 示例:
git checkout pay

#从远程仓库中，把对应的远程分支下载到本地仓库，并把下载的本地分支进行重命名
git checkout -b 本地分支名称 远程仓库名称/远程分支名称
#示例:
git checkout -b payment origin/pay
```

#### 4.拉取远程分支的最新的代码

可以使用如下的命令，把远程分支最新的代码下载到本地对应的分支中：

```
# 从远程仓库，拉取当前分支最新的代码，保持当前分支的代码和远程分支代码一致
git pull
```

#### 5.删除远程分支

可以使用如下的命令，删除远程仓库中指定的分支：

```
# 删除远程仓库中，指定名称的远程分支
git push 远程仓库名称 --delete 远程分支名称
# 示例:
git push origin --delete pay
```

### 5.总结

①能够掌握Git 中基本命令的使用

- git init
- git add .
- git commit –m "提交消息"
- git status 和git status -s

②能够使用Github 创建和维护远程仓库

- 能够配置Github 的SSH 访问
- 能够将本地仓库上传到Github

③能够掌握Git 分支的基本使用

- git checkout -b 新分支名称
- git push -u origin 新分支名称
- git checkout 分支名称
- git branch

## 七、案例1--大事件案例(略)(p249-p341)

略

## 八、初始Node.js与内置模块

### 1.初识Node.js

#### 1.1 回顾与思考

##### 1.已经掌握了哪些技术

- HTML
- CSS
- Javascript

##### 2.浏览器中的JavaScript的组成部分

![image-20211121221047861](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211121221047861.png)

##### 3.思考：为什么骄傲JavaScript可以在浏览器中被执行

![image-20211121221151172](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211121221151172.png)

不同的浏览器使用不同的JavaScript 解析引擎：

- Chrome浏览器 => v8
- Firefox浏览器 => OdinMonkey(奥丁猴)
- Safri浏览器 => JSCore
- IE浏览器 =>Chakra(查克拉)
- etc...

其中，Chrome浏览器的V8解析引擎性能最好！

##### 4.思考：为什么JavaScript可以操作DOM和BOM

![image-20211121221358769](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211121221358769.png)

每个浏览器都内置了DOM、BOM这样的API函数，因此，浏览器中的JavaScript才可以调用它们。

##### 5.浏览器中的JavaScript运行环境

运行环境是指**代码正常运行所需的必要环境**。

![image-20211121221640548](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211121221640548.png)

总结：
①V8引学负责解析和执行JavaScript 代码。
②内置API是由运行环境提供的特殊接口，只能在所属的运行环境中被调用。

##### 6.思考：JavaScript能否做后端开发

java、python、PHP

Node.js

#### 1.2 Node.js简介

##### 1.什么是 Node.js

```
Node.jsR is a JavaScript runtime built on Chrome's V8 JavaScript engine.

Node.js 是一个基于Chrome V8引擎的JavaScript运行环境。
```

Node.js 的官网地址：https://nodejs.org/zh-cn/

Node.js 中文网的官网地址：http://nodejs.cn/

##### 2.Node.js中的JavaScript运行环境

![image-20211121222155908](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211121222155908.png)

注意：
①浏览器是JavaScript的前端运行环境。
②Node.js 是JavaScript 的后端运行环境。
③Node.js 中无法调用DOM和BOM等浏览器内置API。

##### 3.Node.js可以做什么

Node.js作为一个JavaScript 的运行环境，仅仅提供了基础的功能和API。然而，基于Nodejs提供的这些基础能，很多强大的工具和框架如雨后春笋，层出不穷，所以学会了Node.js，可以让前端程序员胜任更多的工作和岗位：

①基于Express框架(http://www.expressjs.com.cn/)，可以快速构建Web 应用
②基于Electron框架(https://electronjs.org/)，可以构建跨平台的桌面应用
③基于restify框架(http://restify.com/)，可以快速构建API接口项目
④读写和操作数据库、创建实用的命令行工具辅助前端开发、etc...

总之：Node.js 是大前端时代的“大宝剑”，有了Node.js这个超级 buff的加持，前端程序员的行业竞争力会越来越强！

##### 4.Node.js好学吗

**好学!**
**会JavaScript。就能学会Node.js! ! !**

##### 4.Node.js 怎么学

浏览器中的JavaScript学习路径：
JavaScript基础语法＋浏览器内置API(DOM + BOM)+第三方库 (jQuery、art-template等)

Node.js 的学习路径：
JavaScript 基础语法＋Nodejs 内置API模块(fs、path、http等)＋第三方API模块(express、mysql等)

#### 1.3 Node.js 环境的安装

如果希望通过Node.js 来运行Javascript代码，则必须在计算机上安装Node.js环境才行。

安装包可以从Node.js的官网首页直接下载，进入到Node.js的官网首页(https://nodejs.org/en/)，点击绿色的按钮。下载所需的版本后，双击直接安装即可。

##### 1.区分LTS版本和Current版本的不同

- LTS为长期稳定版，对于追求稳定性的企业级项目来说，推荐安装LTS版本的 Node.js。
- Current 为新特性尝鲜版，对热衷于尝试新特性的用户来说，推荐安装Current 版本的 Node.js。但是，Current版本中可能存在隐藏的 Bug或安全性漏洞，因此不推荐在企业级项目中使用Current版本的 Node.js。

##### 2.查看已安装的Node.js的版本号

打开终端，在终端输入命令`node -v`后，按下回车键，即可查看已安装的Node.js 的版本号。

Windows系统快速打开终端的方式：
使用快捷键(Windows徽标键＋R)打开运行面板，输入 cmd后直接回车，即可打开终端。

##### 3.什么是终端

终端(英文:Terminal)是专门为开发人员设计的，用于实现人机交互的一种方式。

作为一名合格的程序员，我们有必要识记一些常用的终端命令，来辅助我们更好的操作与使用计算机。

#### 1.4 在Node.js环境中直行JavaScript代码

①打开终端
②输入node要执行的js文件的路径

##### 1.终端中的快捷键

在Windows 的powershell或cmd终端中，我们可以通过如下快捷键，来提高终端的操作效率:

①使用↑键，可以快速定位到上一次执行的命令
②使用tab键，能够快速补全路径
③使用esc键，能够快速清空当前已输入的命令
④输入cls命令，可以清空终端

### 2.fs文件系统模块

#### 2.1 什么是fs 文件系统模块

fs模块是Nodejs官方提供的、用来操作文件的模块。它提供了一系列的方法和属性，用来满足用户对文件的操作需求。例如：

- fs.readFile() 方法，用来**读取**指定文件中的内容
- fs.writeFile()方法，用来向指定的文件中**写入**内容

如果要在JavaScript代码中，使用fs模块来操作文件，则需要使用如下的方式先导入它：

```javascript
const fs = require('fs')
```

#### 2.2 读取指定文件中的内容

##### 1.fs.readFile()的语法格式

使用fs.readFile()方法，可以读取指定文件中的内容，语法格式如下：

```javascript
fs.readFile(path[, options], callback)
```

参数解读:
- 参数1：必选参数，字符串，表示文件的路径。
- 参数2：可选参数，表示以什么编码格式来读取文件。
- 参数3：必选参数，文件读取完成后，通过回调函数拿到读取的结果。

##### 2.fs.readFile()的示例代码

以utf8的编码格式，读取指定文件的内容，并打印err和dataStr 的值：

```javascript
const fs = requile('fs')
fs.readFile('./files/11.txt ', 'utf8', function (err, datastr) {
  console.log(err)
  console.log('-----')
  console.log(datastr)
})
```

##### 3.判断文件是否读取成功

可以判断err 对象是否为null，从而知晓文件读取的结果:

```javascript
const fs = require('fs')
fs.readFile('./files/1.txt', 'utf8', function (err, result) {
  if (err) {
    return console.log('文件读取失败! ' + err.message)
  }
  console.log('文件读取成功，内容是: ' + result)
})
```

#### 2.3 向指定的文件中写入内容

##### 1.fs.writeFile()的语法格式

使用fs.writeFile()方法，可以向指定的文件中写入内容，语法格式如下：

```javascript
fs.writeFile(file, data[, options], callback)
```

参数解读：

- 参数1：必选参数，需要指定一个文件路径的字符串，表示文件的存放路径。
- 参数2：必选参数，表示要写入的内容。
- 参数3：可选参数，表示以什么格式写入文件内容，默认值是utf8。
- 参数4：必选参数，文件写入完成后的回调函数。

##### 2.fs.writeFile()的示例代码

向指定的文件路径中，写入文件内容:

```javascript
const fs = require('fs')

fs.writeFile('./files/2.txt', 'Hello Node.js!', function (err) {
  console.log(err)
})
```

##### 3.判断文件是否写入成功

可以判断err 对象是否为null，从而知晓文件写入的结果：

```javascript
const fs = require('fs')

fs.writeFile('F:/files/2.txt', 'Hello Node.js!', function (err) {
  if (err) {
    return console.log('文件写入失败! ' + err.message)
  }
  console.log('文件写入成功!')
})
```

#### 2.5 练习-考试成绩整理

使用fs文件系统模块，将素材目录下成绩.txt文件中的考试数据，整理到成绩-oktxt文件中。整理前，成绩.txt文件中的数据格式如下：

```
小红=99 小白=100 小黄=78 小黑=66 小绿=88
```

整理完成之后，希望得到的成绩-ok.txt文件中的数据格式如下：

```
小红:99
小白:100
小黄:70
小黑:66
小绿:88
```

##### 核心实现步骤

①导入需要的fs文件系统模块
②使用fs.readFile()方法，读取素材目录下的成绩.txt文件
③判断文件是否读取失败
④文件读取成功后，处理成绩数据
⑤将处理完成的成绩数据，调用fs.writeFile0方法，写入到新文件成绩-ok.txt中

#### 2.6 fs模块–路径动态拼接的问题

在使用fs 模块操作文件时，如果提供的操作路径是以`./`或`../`开头的**相对路径**时，很容易出现路径动态拼接错误的问题。

原因：代码在运行的时候，会以执行node命令时所处的目录，动态拼接出被操作文件的完整路径。

解决方案：在使用fs模块操作文件时，直接提供完整的路径，不要提供以`./`或`../`开头的相对路径，从而防止路径动态拼接的问题。

```javascript
// 不要使用 ./或 ../这样的相对路径
fs.readFile('./files/1.txt', 'utf8', function (err, dataStr) {
  if (err) {
    return console.log('读取文件失败!' + err.message)
  }
  console.log(dataStr)
})

// __dirname表示当前文件所处的目录
fs.readFile(__dirname + '/files/1.txt ', 'utf8', function (err, dataStr) {
  if (err) {
    return console.log('读取文件失败!' + err.message)
  }
  console.log(dataStr)
})
```

### 3.path路径模块

#### 3.1 什么是path路径模块

path模块是Node.js 官方提供的、用来处理路径的模块。它提供了一系列的方法和属性，用来满足用户对路径的处理需求。

例如：

- path.join()方法，用来将多个路径片段拼接成一个完整的路径字符串
- path.basename()方法，用来从路径字符串中，将文件名解析出来

如果要在JavaScript代码中，使用path模块来处理路径，则需要使用如下的方式先导入它：

```javascript
const path = require('path')
```

#### 3.2 路径拼接

##### 1.path.join()的语法格式

使用path.join()方法，可以把多个路径片段拼接为完整的路径字符串，语法格式如下：

```javascript
path.join([..paths])
```

参数解读：

- `...paths <string>`路径片段的序列
- 返回值：`<string>`

##### 2.path.join()的代码示例

使用path.join()方法，可以把多个路径片段拼接为完整的路径字符串：

```javascript
const pathStr = path.join('/a', '/b/c', '../', './d', 'e')
console.log(pathStr) // 输出\a\b\d\e

const pathStr2 = path.join(__dirname, './files/1.txt')
console.log(pathStr2) // 输出当前文件所处目录\files\1.txt
```

注意：今后凡是涉及到路径拼接的操作，都要使用path.join()方法进行处理。不要直接使用＋进行字符串的拼接。

#### 3.3 获取路径中的文件名

##### 1.path.basename()的语法格式

使用path.basename()方法，可以获取路径中的最后一部分，经常通过这个方法获取路径中的文件名，语法格式如下：

```javascript
path.basename(path[, ext])
```

参数解读：

- `path <string>`必选参数，表示一个路径的字符串
- `ext <string>`可选参数，表示文件扩展名
- 返回：`<string>`表示路径中的最后一部分

##### 2.path.basename()的代码示例

使用path.basename)方法，可以从一个文件路径中，获取到文件的名称部分：

```javascript
const fpath = '/a/b/c/index.html' // 文件的存放路径

var fullName = path.basename(fpath)
console.log(fullName) // 输出index.html

var nameWithoutExt = path.basename(fpath, '.html')
console.log(namewithoutExt) // 输出index
```

#### 3.4 获取路径中的文件扩展名

##### 1.path.extname()的语法格式

使用path.extname()方法，可以获取路径中的扩展名部分，语法格式如下：

```javascript
path.extname(path)
```

参数解读：

- `path <string>`必选参数，表示一个路径的字符串
- 返回：`<string>`返回得到的扩展名字符串

##### 2.path.extname()的代码示例

使用path.extname()方法，可以获取路径中的扩展名部分：

```javascript
const fpath = '/a/b/c/index.html' // 路径字符串

const fext = path.extname(fpath)
console.log(fext) // 输出.html
```

#### 3.5 综合案例–时钟案例 (略)

##### 1.案例要实现的功能

![image-20211122101016603](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211122101016603.png)

将素材目录下的index.html页面,拆分成三个文件，分别是：

- index.css
- index.js
- index.html

并且将拆分出来的3个文件，存放到clock目录中。

##### 2.案例的实现步骤

①创建两个正则表达式，分别用来匹配 `<style>` 和 `<script>` 标签
②使用fs模块，读取需要被处理的HTML文件
③自定义resolveCSS方法，来写入index.css样式文件
④自定义resolveJS方法，来写入index.js 脚本文件
⑤自定义resolveHTML 方法，来写入index.html文件


### 4. http模块

#### 4.1 什么是http模块

回顾：什么是客户端、什么是服务器?
在网络节点中，负责消费资源的电脑，叫做客户端；负责对外提供网络资源的电脑，叫做服务器。

http模块是Node.js 官方提供的、用来创建 web服务器的模块。通过 http模块提供的 `http.createServer()`方法，就能方便的把一台普通的电脑，变成一台Web服务器，从而对外提供 Web资源服务。

如果要希望使用http模块创建Web服务器，则需要先导入它：

```javascript
const http = require('http')
```

#### 4.2 进一步理解http模块的作用

服务器和普通电脑的区别在于，服务器上安装了web服务器软件，例如：llS、Apache等。通过安装这些服务器软件，就能把一台普通的电脑变成一台web服务器。

在Node.js 中，我们不需要使用IIS、Apache等这些第三方web服务器软件。因为我们可以基于Node.js提供的http模块，通过几行简单的代码，就能轻松的手写一个服务器软件，从而对外提供web服务。

#### 4.3 服务器相关的概念

##### 1.IP地址

地址就是互联网上每台计算机的唯一地址，因此IP地址具有唯一性。如果把“个人电脑”比作“一台电话”，那么“IP地址”就相当于“电话号码”，只有在知道对方IP地址的前提下，才能与对应的电脑之间进行数据通信。

IP地址的格式：通常用“点分十进制”表示成(a.b.c.d)的形式，其中,a,b,c,d都是0~255之间的十进制整数。例如：用点分十进表示的IP地址(192.168.1.1)

注意：
①互联网中每台Web服务器，都有自己的IP地址，例如：大家可以在Windows的终端中运行`ping www.baidu.com`命令，即可查看到百度服务器的IP地址。
②在开发期间，自己的电脑既是一台服务器，也是一个客户端，为了方便测试，可以在自己的浏览器中输入127.0.0.1这个IP地址，就能把自己的电脑当做一台服务器进行访问了。

##### 2.域名和域名服务器

尽管IP地址能够唯一地标记网络上的计算机，但IP地址是一长串数字，不直观，而且不便于记忆，于是人们又发明了另一套字符型的地址方案，即所谓的**域名(Domain Name)地址**。

IP地址和域名是——对应的关系，这份对应关系存放在一种叫做**域名服务器(DNS，Domain name server)**的电脑中。使用者只需通过好记的域名访问对应的服务器即可，对应的转换工作由域名服务器实现。因此，域名服务器就是提供IРP地址和域名之间的转换服务的服务器。

注意：
①单纯使用IP地址，互联网中的电脑也能够正常工作。但是有了域名的加持，能让互联网的世界变得更加方便。
②在开发测试期间，**127.0.0.1**对应的域名是**localhost**，它们都代表我们自己的这台电脑，在使用效果上没有任何区别。

##### 3.端口号

计算机中的端口号，就好像是现实生活中的门牌号一样。通过门牌号，外卖小哥可以在整栋大楼众多的房间中，准确把外卖送到你的手中。

同样的道理，在一台电脑中，可以运行成百上千个web服务。每个web服务都对应一个唯一的端口号。客户端发送过来的网络请求，通过端口号，可以被准确地交给对应的web服务进行处理。

![image-20211122110047443](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211122110047443.png)

注意：
①每个端口号不能同时被多个web 服务占用。
②在实际应用中，URL中的80端口可以被省略。

#### 4.4 创建最基本的web服务器

##### 1.创建web 服务器的基本步骤

①导入http模块
②创建web 服务器实例
③为服务器实例绑定request事件，监听客户端的请求
④启动服务器

##### 2.步骤1-导入http模块

如果希望在自己的电脑上创建一个web服务器，从而对外提供web服务，则需要导入http模块：

```javascript
const http = require('http')
```

##### 2.步骤2–创建web服务器实例

调用`http.createServer()`方法，即可快速创建一个web 服务器实例：

```javascript
const server = http.createServer()
```

##### 2.步骤3–为服务器实例绑定request事件

为服务器实例绑定request事件，即可监听客户端发送过来的网络请求：

```javascript
// 使用服务器实例的.on()方法，为服务器绑定一个request事件
server.on('request', (req, res) => {
  // 只要有客户端来请求我们自己的服务器，就会触发request 事件，从而调用这个事件处理函数
  console.log('Someone visit our web server.')
})
```

##### 2.步骤4–启动服务器

调用服务器实例的 `.listen()` 方法，即可启动当前的web 服务器实例：

```javascript
// 调用server.listen(端口号，cb回调)方法，即可启动web服务器
server.listen(80, () => {
  console.log('http server running at http://127.0.0.1')
})
```

##### 3.req请求对象

只要服务器接收到了客户端的请求，就会调用通过server.on()为服务器绑定的request事件处理函数。

如果想在事件处理函数中，访问与客户端相关的数据或属性，可以使用如下的方式：

```javascript
server.on('request', (req) => {
  // req是请求对象，它包含了与客户端相关的数据和属性，例妆:
  // req.url是客户端请求的 URL地址
  // req.method 是客户端的method请求类型
  const str = `Your request url is ${req.url}, and request method is ${req.method}`
  console.log(str)
})
```

##### 4.res响应对象

在服务器的request事件处理函数中，如果想访问与服务器相关的数据或属性，可以使用如下的方式：

```javascript
server.on('request', (req, res) => {
  // res是响应对象，它包含了与服务器相关的数据和属性，例如:
  // 要发送到客户端的字符串
  const str = `Your request url is ${req.url}, and request method is ${req.method}`
  // res.end()方法的作用:
  // 向客户端发送指定的内容，并结束这次请求的处理过程
  res.end(str)
})
```

##### 5.解决中文乱码问题

当调用 `res.end()` 方法，向客户端发送中文内容的时候，会出现乱码问题，此时，需要手动设置内容的编码格式：

```javascript
server.on('request', (req, res) => {
  // 发送的内容包含中文
  const str = `您请求的url地址是${req.url}, 请求的method类型是${req.method}`
  // 为了防止中文显示乱码的问题，需要设置响应头Content-Type 的值为 text/html; charset=utf-8
  res.setHeader('Content-Type', 'text/html; charset=utf-8')
  // 把包含中文的内容，响应给客户端
  res.end(str)
})
```

#### 4.5 根据不同的url响应不同的html内容

##### 1.核心实现步骤

①获取请求的url地址
②设置默认的响应内容为 `404 Not found`
③判断用户请求的是否为 `/` 或 `/index.html` 首页
④判断用户请求的是否为 `/about.html` 关于页面
⑤设置Content-Type响应头，防止中文乱码
⑥使用 `res.end()` 把内容响应给客户端

##### 2.动态响应内容

```javascript
server.on('request', function (req, res) {
  const url = req.url // 1. 获取请求的url地址
  let content = '<h1>404 Not found!</h1>' // 2. 设置默认的内容为404 Not found
  if (url === '/' || url === '/index.html') {
    content = '<h1>首页</h1>' // 3. 用户请求的是首页
  } else if (url === '/about.html') {
    content = '<h1>关于页面</h1>' // 4. 用户请求的是关于页面
  }
  res.setHeader('Content-Type', 'text/html; charset=utf-8') // 5. 设置Content-Type响应头，防止中文乱码
  res.end(content) // 把内容发送给客户端
})
```

#### 4.6 案例-实现clock时钟的web服务器

##### 1.核心思路

把文件的实际存放路径，作为每个资源的请求url地址。

![image-20211128092253079](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211128092253079.png)

##### 2.实现步骤

①导入需要的模块
②创建基本的web 服务器
③将资源的请求url地址映射为文件的存放路径
④读取文件内容并响应给客户端
⑤优化资源的请求路径

##### 3.步骤1-导入需要的模块

```javascript
// 1.1 导入http模块
const http = require('http')
// 1.2 导入fs文件系统模块
const fs = require('fs')
// 1.3 导入 path路径处理模块
const path = require('path')
```

##### 3.步骤2–创建基本的web服务器

```javascript
// 2.1 创建web服务器
const server = http.createServer()

// 2.2 监听 web服务器的request 事件
server.on('request', function (req, res) {})

// 2.3 启动web服务器
server.listen(80, function () {
  console.log('server listen at http://127.0.0.1')
})
```

##### 3.步骤3–将资源的请求url地址映射为文件的存放路径

```javascript
// 3.1 获取到客户端请求的url地址
const url = req.url
// 3.2 把请求的url 地址，映射为本地文件的存放路径
const fpath = path.join(__dirname, url)
```

##### 3.步骤4–读取文件的内容并响应给客户端

```javascript
// 4.1 根据"映射"过来的文件路径读取文件
fs.readFile(fpath, 'utf8', (err, dataStr) => {
  // 4.2 读取文件失败后，向客户端响应固定的“错误消息”
  if (err) return res.end('404 Not fount.')
  // 4.3 读取文件成功后，将"读取成功的内容"响应给客户端
  res.end(dataStr)
})
```

##### 骤5–优化资源的请求路径

```javascript
// 将3.2的实现方式，改为如下代码
// 5.1 预定义空白的文件存放路径
let fpath = ''
if (ur1 === '/') {
  // 5.2 如果请求的路径是否为 /，则手动指定文件的存放路径
  fpath = path.join(__dirname, './clock/index.html')
} else {
  // 5.3 如果请求的路径不为 /，则动态拼接文件的存放路径
  fpath = path.join(___dirname, './clock', url)
}
```

## 九、模块化

### 1.模块化的基本概念

#### 1.1 什么是模块化

模块化是指解决一个复杂问题时，自顶向下逐层把系统划分成若干模块的过程。对于整个系统来说，模块是可组合、分解和更换的单元。

##### 1.现实生活中的模块化

小霸王游戏机的插卡

##### 2.编程领域中的模块化

编程领域中的模块化，就是遵守固定的规则，把一个大文件拆成独立并互相依赖的多个小模块。

把代码进行模块化拆分的好处：
①提高了代码的复用性
②提高了代码的可维护性
③可以实现按需加载

#### 1.2 模块化规范

模块化规范就是对代码进行模块化的拆分与组合时，需要遵守的那些规则。

例如：

- 使用什么样的语法格式来引用模块
- 在模块中使用什么样的语法格式向外暴露成员


模块化规范的好处：大家都遵守同样的模块化规范写代码，降低了沟通的成本，极大方便了各个模块之间的相互调用，利人利己。

### 2.Node.js 中的模块化

#### 2.1 Node.js中模块的分类

Node.js 中根据模块来源的不同，将模块分为了3 大类，分别是：

- 内置模块（内置模块是由Node.js 官方提供的，例如fs、path、http 等）
- 自定义模块（用户创建的每个.js 文件，都是自定义模块）
- 第三方模块（由第三方开发出来的模块，并非官方提供的内置模块，也不是用户创建的自定义模块，使用前需要先下载）

#### 2.2 加载模块

使用强大的 `require()` 方法，可以加载需要的内置模块、用户自定义模块、第三方模块进行使用。例如：

```javascript
// 1. 加载内置的fs模块
const fs = require('fs')

// 2. 加载用户的自定义模块
const custom = require('./custom.js')

// 3. 加载第三方模块(关于第三方模块的下载和使用，会在后面的课程中进行专门的讲解)
const moment = require('moment')
```

注意：使用 `require()` 方法加载其它模块时，会执行被加载模块中的代码。

注意：在使用 require 加载用户自定义模块期间，可以省略 .js 的后缀名

#### 2.3 Node.js中的模块作用域

##### 1.什么是模块作用域

和函数作用域类似，在自定义模块中定义的变量、方法等成员，只能在当前模块内被访问，这种模块级别的访问限制，叫做模块作用域。

##### 2.模块作用域的好处

防止了全局变量污染的问题

#### 2.4 向外共享模块作用域中的成员

##### 1.module对象

在每个.js 自定义模块中都有一个module 对象，它里面存储了和当前模块有关的信息，打印如下：

![image-20211128095848128](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211128095848128.png)

##### 2.module.exports 对象

在自定义模块中，可以使用module.exports 对象，将模块内的成员共享出去，供外界使用。
外界用require() 方法导入自定义模块时，得到的就是module.exports 所指向的对象。

##### 3.共享成员时的注意点

使用require() 方法导入模块时，导入的结果，永远以module.exports 指向的对象为准。

![image-20211128100413505](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211128100413505.png)

##### 4.exports 对象

由于module.exports单词写起来比较复杂，为了简化向外共享成员的代码，Node 提供了exports对象。默认情况下，exports 和module.exports 指向同一个对象。最终共享的结果，还是以module.exports指向的对象为准。

##### 4.exports 和module.exports 的使用误区

时刻谨记，require() 模块时，得到的永远是module.exports指向的对象：

![image-20211128101303566](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211128101303566.png)

![image-20211128101102754](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211128101102754.png)

注意：为了防止混乱，建议大家不要在同一个模块中同时使用exports 和module.exports

#### 2.5 Node.js中的模块化规范

Node.js 遵循了CommonJS 模块化规范，CommonJS 规定了模块的特性和各模块之间如何相互依赖。

CommonJS 规定：
①每个模块内部，module 变量代表当前模块。
②module 变量是一个对象，它的exports 属性 (即module.exports) 是对外的接口。
③加载某个模块，其实是加载该模块的module.exports 属性。require() 方法用于加载模块。

### 3.npm与包

#### 3.1 包

##### 1.什么是包

Node.js 中的第三方模块又叫做包。

就像电脑和计算机指的是相同的东西，第三方模块和包指的是同一个概念，只不过叫法不同。

##### 2.包的来源

不同于Node.js 中的内置模块与自定义模块，包是由第三方个人或团队开发出来的，免费供所有人使用。

注意：Node.js 中的包都是免费且开源的，不需要付费即可免费下载使用。

##### 3.为什么需要包

由于Node.js 的内置模块仅提供了一些底层的API，导致在基于内置模块进行项目开发的时，效率很低。

包是基于内置模块封装出来的，提供了更高级、更方便的API，极大的提高了开发效率。
包和内置模块之间的关系，类似于jQuery和浏览器内置API 之间的关系。

##### 4.从哪里下载包

国外有一家IT 公司，叫做npm, Inc. 这家公司旗下有一个非常著名的网站：https://www.npmjs.com/，它是全球最大的包共享平台，你可以从这个网站上搜索到任何你需要的包，只要你有足够的耐心！

到目前位置，全球约1100 多万的开发人员，通过这个包共享平台，开发并共享了超过120 多万个包供我们使用。

npm, Inc. 公司提供了一个地址为https://registry.npmjs.org/的服务器，来对外共享所有的包，我们可以从这个服务器上下载自己所需要的包。

注意：

- 从https://www.npmjs.com/网站上搜索自己所需要的包
- 从https://registry.npmjs.org/服务器上下载自己需要的包

##### 5.如何下载包

npm, Inc. 公司提供了一个包管理工具，我们可以使用这个包管理工具，从https://registry.npmjs.org/服务器把需要的包下载到本地使用。

这个包管理工具的名字叫做Node Package Manager（简称npm 包管理工具），这个包管理工具随着Node.js 的安装包一起被安装到了用户的电脑上。

大家可以在终端中执行 `npm -v` 命令，来查看自己电脑上所安装的npm 包管理工具的版本号：

```
C:\Users\ASUS>npm -v
8.1.0
```

#### 3.2 npm 初体验

##### 1.格式化时间的传统做法

①创建格式化时间的自定义模块
②定义格式化时间的方法
③创建补零函数
④从自定义模块中导出格式化时间的函数
⑤导入格式化时间的自定义模块
⑥调用格式化时间的函数

##### 2.格式化时间的高级做法

①使用npm 包管理工具，在项目中安装格式化时间的包moment
②使用require() 导入格式化时间的包
③参考moment 的官方API 文档对时间进行格式化

```javascript
// 1. 导入moment包
const moment = require('moment')

// 2. 参考moment官方API文档，调用对应的方法，对时间进行格式化
// 2.1 调用moment()方法，得到当前的时间
// 2.2 针对当前的时间，调用format()方法，按照指定的格式进行时间的格式化
const dt = moment().format('YYYY-MM-DD HH:mm:ss')

console.log(dt) // 输出2020-01-12 17:23:48
```

##### 3.在项目中安装包的命令

如果想在项目中安装指定名称的包，需要运行如下的命令：

```
npm install 包的完整名称
```


上述的装包命令，可以简写成如下格式：

```
npm i 包的完整名称
```

##### 4.初次装包后多了哪些文件

初次装包完成后，在项目文件夹下多一个叫做node_modules的文件夹和package-lock.json的配置文件。

其中：

- node_modules 文件夹用来存放所有已安装到项目中的包。require() 导入第三方包时，就是从这个目录中查找并加载包。
- package-lock.json配置文件用来记录node_modules 目录下的每一个包的下载信息，例如包的名字、版本号、下载地址等。

注意：程序员不要手动修改node_modules 或package-lock.json文件中的任何代码，npm 包管理工具会自动维护它们。

##### 5.安装指定版本的包

默认情况下，使用npm install 命令安装包的时候，会自动安装最新版本的包。如果需要安装指定版本的包，可以在包名之后，通过@ 符号指定具体的版本，例如：

```
npm i moment@2.22.2
```

##### 6.包的语义化版本规范

包的版本号是以“点分十进制”形式进行定义的，总共有三位数字，例如2.24.0

其中每一位数字所代表的的含义如下：
第1位数字：大版本
第2位数字：功能版本
第3位数字：Bug修复版本

版本号提升的规则：只要前面的版本号增长了，则后面的版本号归零。

#### 3.3 包管理配置文件

npm规定，在项目根目录中，必须提供一个叫做package.json的包管理配置文件。用来记录与项目有关的一些配置信息。例如：

- 项目的名称、版本号、描述等
- 项目中都用到了哪些包
- 哪些包只在开发期间会用到
- 那些包在开发和部署时都需要用到

##### 1.多人协作的问题

整个项目的体积是30.4M
第三方包的体积是28.8M
项目源代码的体积1.6M

遇到的问题：第三方包的体积过大，不方便团队成员之间共享项目源代码。

解决方案：共享时剔除node_modules

##### 2.如何记录项目中安装了哪些包

在项目根目录中，创建一个叫做package.json的配置文件，即可用来记录项目中安装了哪些包。从而方便剔除node_modules目录之后，在团队成员之间共享项目的源代码。

**注意：今后在项目开发中，一定要把node_modules文件夹，添加到.gitignore忽略文件中。**

##### 3.快速创建package.json

npm 包管理工具提供了一个快捷命令，可以在执行命令时所处的目录中，快速创建package.json 这个包管理配置文件：

```
// 作用：在执行命令所处的目录中，快速新建 package.json 文件
npm init -y
```

注意：
①上述命令只能在英文的目录下成功运行！所以，项目文件夹的名称一定要使用英文命名，不要使用中文，不能出现空格。
②运行 `npm install` 命令安装包的时候，npm包管理工具会自动把包的名称和版本号，记录到package.json中。

##### 4.dependencies节点

`package.json` 文件中，有一个`dependencies`节点，专门用来记录您使用 `npm install` 命令安装了哪些包。

##### 5.一次性安装所有的包

当我们拿到一个剔除了node_modules 的项目之后，需要先把所有的包下载到项目中，才能将项目运行起来。
否则会报类似于下面的错误：

```
// 由于项目运行依赖于 moment 这个包，如果没有提前安装好这个包就会收到如下的错误：
Error: Cannot find module 'moment'
```

可以运行 `npm install` 命令 (或 `npm i` ) 一次性安装所有的依赖包：

```
// 执行npm install 命令时，npm 包管理工具会先读取package.json 中的 dependencies 节点,
// 读取到记录的所有依赖包名称和版本号之后，npm包管理工具会把这些包一次性下载到项目中
npm install
```

##### 6.卸载包

可以运行 `npm uninstall` 命令，来卸载指定的包：

```
// 使用npm uninstall具体的包名来卸载包
npm uninstall moment
```

注意：`npm uninstall` 命令执行成功后，会把卸载的包，自动从 `package.json` 的`dependencies` 中移除掉。

##### 7.devDependencies节点

如果某些包只在项目开发阶段会用到，在项目上线之后不会用到，则建议把这些包记录到 `devDependencies` 节点中。

与之对应的，如果某些包在开发和项目上线之后都需要用到，则建议把这些包记录到dependencies 节点中。

您可以使用如下的命令，将包记录到devDependencies节点中：

```
// 安装指定的包，并记录到 devDependencies节点中
npm i 包名 -D
// 注意:上述命令是简写形式，等价于下面完整的写法:
npm install 包名 --save-dev
```

#### 3.4 解决下包速度慢的问题

##### 1.为什么下包速度慢

在使用npm 下包的时候，默认从国外的 https://registry.npmjs.org/服务器进行下载，此时，网络数据的传输需要经过漫长的海底光缆，因此下包速度会很慢。

扩展阅读-海底光缆：

- https://baike.baidu.com/item/%E6%B5%B7%E5%BA%95%E5%85%89%E7%BC%86/4107830
- https://baike.baidu.com/item/%E4%B8%AD%E7%BE%8E%E6%B5%B7%E5%BA%95%E5%85%89%E7%BC%86/10520363
- https://baike.baidu.com/item/APG/23647721?fr=aladdin

##### 2.淘宝NPM镜像服务器

![image-20211130114753957](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211130114753957.png)

淘宝在国内搭建了一个服务器，专门把国外官方服务器上的包同步到国内的服务器，然后在国内提供下包的服务。从而极大的提高了下包的速度。

扩展：镜像 (Mirroring) 是一种文件存储形式，一个磁盘上的数据在另一个磁盘上存在一个完全相同的副本即为镜像。

##### 3.切换npm的下包镜像源

下包的镜像源，指的就是下包的服务器地址。

```
# 查看当前的下包镜像源
npm config get registry
# 将下包的镜像源切换为淘宝镜像源
npm config set registry=https://registry.npm.taobao.org/
# 检查镜像源是否下载成功
npm config get registry

# 官方的下载包地址
http://registry.npmjs.org/
```

##### 4.nrm

为了更方便的切换下包的镜像源，我们可以安装nrm这个小工具，利用nrm提供的终端命令，可以快速查看和切换下包的镜像源。

```
# 通过npm包管理器，将nrm安装为全局可用的工具
npm i nrm -g
# 查看所有可用的镜像源
nrm ls
	npm--------https://registry.npmjs.org/
	yarn-------https://registry.yarnpkg.com/
	cnpm-------http://r.cnpmjs.org/
	taobao-----https://registry.npm.taobao.org/
	nj---------https://registry.nodejitsu.com/
	npmMirror--https://skimdb.npmjs.com/registry/
	edunpm-----http://registry.enpmjs.org/
# 将下包的镜像源切换为taobao镜像
nrm use taobao
```

#### 3.5 包的分类

使用npm 包管理工具下载的包，共分为两大类，分别是：

- 项目包
- 全局包

##### 1.项目包

那些被安装到项目的node_modules 目录中的包，都是项目包。

项目包又分为两类，分别是：

- 开发依赖包 (被记录到 `devDependencies` 节点中的包，只在开发期间会用到)
- 核心依赖包 (被记录到 `dependencies` 节点中的包，在开发期间和项目上线之后都会用到)

```
npm i 包名 -D
# 开发依赖包(会被记录到devDependencies节点下)

npm i 包名
# 核心依赖包(会被记录到dependencies节点下)
```

##### 2.全局包

在执行 `npm install` 命令时，如果提供了 `-g` 参数，则会把包安装为全局包。
全局包会被安装到 `C:\Users\用户目录\AppData\Roaming\npm\node_modules` 目录下。

```
npm i 包名 -g
# 全局安装指定的包

npm uninstall 包名 -g
# 卸载全局安装的包
```

注意：
①只有工具性质的包，才有全局安装的必要性。因为它们提供了好用的终端命令。
②判断某个包是否需要全局安装后才能使用，可以参考官方提供的使用说明即可。

##### 3.i5ting_toc

i5ting_toc 是一个可以把md 文档转为html 页面的小工具，使用步骤如下：

```
# 将i5ting_toc安装为全局包
npm install -g i5ting_toc
# 调用i5ting_toc，轻松实现 md 转html 的功能
i5ting_toc -f 要转换的md文件路径 -o
```

#### 3.6 规范的包结构

在清楚了包的概念、以及如何下载和使用包之后，接下来，我们深入了解一下包的内部结构。

一个规范的包，它的组成结构，必须符合以下3 点要求：
①包必须以单独的目录而存在
②包的顶级目录下要必须包含 `package.json` 这个包管理配置文件
③ `package.json` 中必须包含name，version，main这三个属性，分别代表包的名字、版本号、包的入口。

注意：以上3 点要求是一个规范的包结构必须遵守的格式，关于更多的约束，可以参考如下网址：https://yarnpkg.com/zh-Hans/docs/package-json

#### 3.7 开发属于自己的包 (略)

##### 1.需要实现的功能

##### 2.初始化包的基本结构

①新建itheima-tools 文件夹，作为包的根目录
②在itheima-tools 文件夹中，新建如下三个文件：

- package.json （包管理配置文件）
- index.js          （包的入口文件）
- README.md  （包的说明文档）

##### 3.初始化package.json

关于更多license 许可协议相关的内容，可参考https://www.jianshu.com/p/86251523e898

##### 4.在index.js 中定义格式化时间的方法

##### 5.在index.js 中定义转义HTML 的方法

##### 6.在index.js 中定义还原HTML 的方法

##### 7.将不同的功能进行模块化拆分

①将格式化时间的功能，拆分到src -> dateFormat.js 中
②将处理HTML 字符串的功能，拆分到src -> htmlEscape.js 中
③在index.js 中，导入两个模块，得到需要向外共享的方法
④在index.js 中，使用module.exports 把对应的方法共享出去

##### 8.编写包的说明文档

包根目录中的README.md 文件，是包的使用说明文档。通过它，我们可以事先把包的使用说明，以markdown 的格式写出来，方便用户参考。

README 文件中具体写什么内容，没有强制性的要求；只要能够清晰地把包的作用、用法、注意事项等描述清楚即可。

我们所创建的这个包的README.md 文档中，会包含以下6 项内容：
安装方式、导入方式、格式化时间、转义HTML 中的特殊字符、还原HTML 中的特殊字符、开源协议

#### 3.8 发布包 (略)

##### 1.注册npm 账号

①访问https://www.npmjs.com/网站，点击sign up 按钮，进入注册用户界面
②填写账号相关的信息：Full Name、Public Email、Username、Password
③点击Create an Account 按钮，注册账号
④登录邮箱，点击验证链接，进行账号的验证

##### 2.登录npm 账号

npm 账号注册完成后，可以在终端中执行npm login 命令，依次输入用户名、密码、邮箱后，即可登录成功。


注意：在运行npmlogin 命令之前，必须先把下包的服务器地址切换为npm的官方服务器。否则会导致发布包失败！

##### 3.把包发布到npm 上

将终端切换到包的根目录之后，运行npm publish 命令，即可将包发布到npm 上（注意：包名不能雷同）。

##### 4.删除已发布的包

运行npm unpublish 包名--force命令，即可从npm 删除已发布的包。

注意：
①npm unpublish 命令只能删除72 小时以内发布的包
②npm unpublish 删除的包，在24 小时内不允许重复发布
③发布包的时候要慎重，尽量不要往npm 上发布没有意义的包！

### 4.模块的加载机制

#### 4.1 优先从缓存中加载

模块在第一次加载后会被缓存。这也意味着多次调用require() 不会导致模块的代码被执行多次。

注意：不论是内置模块、用户自定义模块、还是第三方模块，它们都会优先从缓存中加载，从而提高模块的加载效率。

#### 4.2 内置模块的加载机制

内置模块是由Node.js 官方提供的模块，内置模块的加载优先级最高。

例如，`require('fs')` 始终返回内置的fs 模块，即使在node_modules 目录下有名字相同的包也叫做fs。

#### 4.3 自定义模块的加载机制

使用require() 加载自定义模块时，必须指定以./或../开头的路径标识符。在加载自定义模块时，如果没有指定./ 或../ 这样的路径标识符，则node 会把它当作内置模块或第三方模块进行加载。

同时，在使用require() 导入自定义模块时，如果省略了文件的扩展名，则Node.js 会按顺序分别尝试加载以下的文件：
①按照确切的文件名进行加载
②补全.js扩展名进行加载
③补全.json 扩展名进行加载
④补全.node 扩展名进行加载
⑤加载失败，终端报错

#### 4.4 第三方模块的加载机制

如果传递给require() 的模块标识符不是一个内置模块，也没有以‘./’ 或‘../’ 开头，则Node.js 会从当前模块的父目录开始，尝试从 `/node_modules` 文件夹中加载第三方模块。
如果没有找到对应的第三方模块，则移动到再上一层父目录中，进行加载，直到文件系统的根目录。

例如，假设在'C:\Users\itheima\project\foo.js' 文件里调用了require('tools')，则Node.js 会按以下顺序查找：
① `C:\Users\itheima\project\node_modules\tools`
② `C:\Users\itheima\node_modules\tools`
③ `C:\Users\node_modules\tools`
④ `C:\node_modules\tools`

#### 4.5 目录作为模块

当把目录作为模块标识符，传递给require() 进行加载的时候，有三种加载方式：
①在被加载的目录下查找一个叫做package.json 的文件，并寻找main 属性，作为require() 加载的入口
②如果目录里没有package.json 文件，或者main 入口不存在或无法解析，则Node.js 将会试图加载目录下的index.js 文件。
③如果以上两步都失败了，则Node.js 会在终端打印错误消息，报告模块的缺失：`Error: Cannot find module 'xxx'`

## 十、Express (注意点)

### 1.初识Express

#### 1.1 Express 简介

##### 1.什么是Express

官方给出的概念：Express 是基于Node.js 平台，快速、开放、极简的Web 开发框架。

通俗的理解：Express 的作用和Node.js 内置的http 模块类似，是专门用来创建Web 服务器的。

Express 的本质：就是一个npm 上的第三方包，提供了快速创建Web 服务器的便捷方法。

Express 的中文官网：http://www.expressjs.com.cn/

##### 2.进一步理解Express

思考：不使用Express 能否创建Web 服务器？
答案：能，使用Node.js 提供的原生http 模块即可。

思考：既生瑜何生亮 (有了http 内置模块，为什么还有用Express) ？
答案：http 内置模块用起来很复杂，开发效率低；Express 是基于内置的http 模块进一步封装出来的，能够极大的提高开发效率。

思考：http 内置模块与Express 是什么关系？
答案：类似于浏览器中Web API 和jQuery 的关系。后者是基于前者进一步封装出来的。

##### 3.Express 能做什么

对于前端程序员来说，最常见的两种服务器，分别是：

- Web 网站服务器：专门对外提供Web 网页资源的服务器。
- API 接口服务器：专门对外提供API 接口的服务器。


使用Express，我们可以方便、快速的创建Web 网站的服务器或API 接口的服务器。

#### 1.2 Express 的基本使用

##### 1.安装

在项目所处的目录中，运行如下的终端命令，即可将express 安装到项目中使用：

```
npm i express@4.17.1
```

##### 2.创建基本的Web 服务器

```javascript
// 1. 导入express
const express = require('express')
// 2. 创建web 服务器
const app = express()

// 3. 调用app.listen(端口号，启动成功后的回调函数)，启动服务器
app.listen(80, () => {
  console.log('express server running at http://127.0.0.1')
})
```

##### 3.监听GET 请求

通过 `app.get()` 方法，可以监听客户端的GET 请求，具体的语法格式如下：

```javascript
// 参数1:客户端请求的URL地址
// 参数2:请求对应的处理函数"
// req:请求对象（包含了与请求相关的属性与方法)
// res:响应对象(包含了与响应相关的属性与方法)
app.get('请求URL', function (req, res) {
  /*处理函数*/
})
```

##### 4.监听POST 请求

通过 `app.post()` 方法，可以监听客户端的POST 请求，具体的语法格式如下：

```javascript
// 参数1:客户端请求的 URL地址
// 参数2:请求对应的处理函数
// req:请求对象〔包含了与请求相关的厨性与方法)
// res:响应对象〔包含了与响应相关的属性与方法)
app.post('请求URL', function (req, res) {
  /*处理函数*/
})
```

##### 5.把内容响应给客户端

通过 `res.send()` 方法，可以把处理好的内容，发送给客户端：

```javascript
app.get('/user', (req, res) => {
  // 向客户端发送JSON对象
  res.send({ name: 'zs', age: 20, gender: '男' })
})

app.post('/user', (req, res) => {
  // 向客户端发送文本内容
  res.send('请求成动')
})
```

##### 6.获取URL 中携带的查询参数

通过 `req.query` 对象，可以访问到客户端通过查询字符串的形式，发送到服务器的参数：

```javascript
app.get('/', (req, res) => {
  // req.query 默认是一个空对象
  // 客户端使用 ?name=zs&age=20 这种查询字符串形式，发送到服务器的参数，
  // 可以通过req.query 对象访问到，例如:
  // req.query.name
  // req.query.age
  console.log(req.query)
})
```

##### 7.获取URL 中的动态参数

通过 `req.params` 对象，可以访问到URL 中，通过:匹配到的动态参数：

```javascript
// URL地址中，可以通过 :参数名 的形式，些配同态参数值
app.get('/user/:id', (req, res) => {
  // req.params默认是一个空对您
  // 里面存放着通过:动态匹配到的参数值
  console.log(req.params)
})
```

#### 1.3 托管静态资源

##### 1. express.static()

express 提供了一个非常好用的函数，叫做express.static()，通过它，我们可以非常方便地创建一个静态资源服务器，例如，通过如下代码就可以将public 目录下的图片、CSS 文件、JavaScript 文件对外开放访问了：

```javascript
app.use(express.static('public'))
```

现在，你就可以访问public 目录中的所有文件了：
http://localhost:3000/images/bg.jpg
http://localhost:3000/css/style.css
http://localhost:3000/js/login.js

注意：Express 在指定的静态目录中查找文件，并对外提供资源的访问路径。因此，存放静态文件的目录名不会出现在URL 中。

##### 2.托管多个静态资源目录

如果要托管多个静态资源目录，请多次调用express.static() 函数：

```javascript
app.use(express.static('public'))
app.use(express.static('files'))
```


访问静态资源文件时，`express.static()` 函数会根据目录的添加顺序查找所需的文件。

##### 3.挂载路径前缀

如果希望在托管的静态资源访问路径之前，挂载路径前缀，则可以使用如下的方式：

```javascript
app.use('/public', express.static('public'))
```

现在，你就可以通过带有/public 前缀地址来访问public 目录中的文件了：
http://localhost:3000/public/images/kitten.jpg
http://localhost:3000/public/css/style.css
http://localhost:3000/public/js/app.js

#### 1.4 nodemon

##### 1.为什么要使用nodemon

在编写调试Node.js 项目的时候，如果修改了项目的代码，则需要频繁的手动close 掉，然后再重新启动，非常繁琐。

现在，我们可以使用nodemon (https://www.npmjs.com/package/nodemon) 这个工具，它能够监听项目文件的变动，当代码被修改后，nodemon会自动帮我们重启项目，极大方便了开发和调试。

##### 2.安装nodemon

在终端中，运行如下命令，即可将nodemon安装为全局可用的工具：

```
npm install -g nodemon
```

##### 3.使用nodemon

当基于Node.js 编写了一个网站应用的时候，传统的方式，是运行 `node app.js` 命令，来启动项目。这样做的坏处是：代码被修改之后，需要手动重启项目。

现在，我们可以将node 命令替换为nodemon命令，使用 `nodemon app.js` 来启动项目。这样做的好处是：代码被修改之后，会被nodemon监听到，从而实现自动重启项目的效果。

```
node app.js
# 将上面的终端命令，替换为下面的终端命令，即可实现自动重启项目的效果
nodemon app.js
```

### 2.Express 路由

#### 2.1 路由的概念

##### 1.什么是路由

广义上来讲，路由就是映射关系。

##### 2.现实生活中的路由

```
按键1  ->  业务查询
按键2  ->  手机充值
按键3  ->  业务办理
按键4  ->  密码服务与停复机
按键5  ->  家庭宽带
按键6  ->  话费流量
按键8  ->  集团业务
按键0  ->  人工服务
```


在这里，路由是按键与服务之间的映射关系。

##### 3.Express 中的路由

在Express 中，路由指的是客户端的请求与服务器处理函数之间的映射关系。

Express 中的路由分3 部分组成，分别是请求的类型、请求的URL 地址、处理函数，格式如下：

```javascript
app.METHOD(PATH, HANDLER)
```

##### 4.Express 中的路由的例子

```javascript
// 匹配GET请求，且请求URL为 /
app.get('/', function (req, res) {
  res.send('Hello World!')
})

// 匹配POST请求，且请求URL为 /
app.post('/', function (req, res) {
  res.send('Got a POST request')
})
```

##### 5.路由的匹配过程

每当一个请求到达服务器之后，需要先经过路由的匹配，只有匹配成功之后，才会调用对应的处理函数。

在匹配时，会按照路由的顺序进行匹配，如果请求类型和请求的URL 同时匹配成功，则Express 会将这次请求，转交给对应的function 函数进行处理。

![image-20211130145332821](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211130145332821.png)

路由匹配的注意点：
①按照定义的先后顺序进行匹配
②请求类型和请求的URL同时匹配成功，才会调用对应的处理函数

#### 2.2 路由的使用

##### 1.最简单的用法

在Express 中使用路由最简单的方式，就是把路由挂载到app 上，示例代码如下：

```javascript
const express = require('express')
// 创建web服务器, 命名为app
const app = express()

// 挂载路由
app.get('/', (req, res) => {
  res.send('Hello world.')
})
app.post('/', (req, res) => {
  res.send('Post Request.')
})

// 启动web服务器
app.listen(80, () => {
  console.log('server running at http://127.0.0.1')
})
```

##### 2.模块化路由

为了方便对路由进行模块化的管理，Express 不建议将路由直接挂载到app 上，而是推荐将路由抽离为单独的模块。

将路由抽离为单独模块的步骤如下：
①创建路由模块对应的.js 文件
②调用express.Router() 函数创建路由对象
③向路由对象上挂载具体的路由
④使用module.exports 向外共享路由对象
⑤使用app.use() 函数注册路由模块

##### 3.创建路由模块

```javascript
var express = require('express') // 1. 导入 express
var router = express.Router() // 2. 创建路由对象

router.get('/user/list', function (req, res) {
  // 3. 挂载获取用户列表的路由
  res.send('Get user list.')
})
router.post('/user/add', function (req, res) {
  // 4. 挂载添加用户的路由
  res.send('Add new user.')
})

module.exports = router // 5. 向外导出路由对象
```

##### 4.注册路由模块

```javascript
// 1. 导入路由模块
const userRouter = require('./router/user.js')

// 2. 使用app.use(）注册路由模块
app.use(userRouter)
```

##### 5.为路由模块添加前缀

类似于托管静态资源时，为静态资源统一挂载访问前缀一样，路由模块添加前缀的方式也非常简单：

```javascript
// 1. 导入路由模块
const userRouter = require('./router/user.js')

// 2. 使用app.use()注册路由模块，并添加统一的访问前缀 /api
app.use('/api', userRouter)
```

### 3.Express 中间件

#### 3.1 中间件的概念

##### 1.什么是中间件

中间件 (Middleware)，特指业务流程的中间处理环节。

##### 2.现实生活中的例子

在处理污水的时候，一般都要经过三个处理环节，从而保证处理过后的废水，达到排放标准。

![image-20211130151622034](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211130151622034.png)

处理污水的这三个中间处理环节，就可以叫做中间件。

##### 3.Express 中间件的调用流程

当一个请求到达Express 的服务器之后，可以连续调用多个中间件，从而对这次请求进行预处理。

![image-20211201075422618](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211201075422618.png)

##### 4.Express 中间件的格式

Express 的中间件，本质上就是一个function 处理函数，Express 中间件的格式如下：

![image-20211201075441636](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211201075441636.png)

注意：中间件函数的形参列表中，必须包含next 参数。而路由处理函数中只包含req 和res。

##### 5.next 函数的作用

next 函数是实现多个中间件连续调用的关键，它表示把流转关系转交给下一个中间件或路由。

![image-20211201075457795](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211201075457795.png)

#### 3.2 Express 中间件的初体验

##### 1.定义中间件函数

可以通过如下的方式，定义一个最简单的中间件函数：

```javascript
// 常量 mw 所指向的，就是一个中间件函数
const mw = function (req, res, next) {
  console.log('这是一个最简单的中间件函数')
  // 注意:在当前中问件的业务处理完毕后,必须调用next()函数
  // 表示把流转关系转交给下一个中间件或路由
  next()
}
```

##### 2.全局生效的中间件

客户端发起的任何请求，到达服务器之后，都会触发的中间件，叫做全局生效的中间件。

通过调用 `app.use` (中间件函数)，即可定义一个全局生效的中间件，示例代码如下：

```javascript
// 常里 mw 所指向的，就是一个中间件函数
const mw = function (req, res, next) {
  console.log('这是一个最简单的中间件至数')
  next()
}

// 全局生效的中间件
app.use(mw)
```

##### 3.定义全局中间件的简化形式

```javascript
// 全局生效的中间件
app.use(function (req, res, next) {
  console.log('这是一个最简单的中间件函数')
  next()
})
```

##### 4.中间件的作用

多个中间件之间，共享同一份req和res。基于这样的特性，我们可以在上游的中间件中，统一为req 或res 对象添加自定义的属性或方法，供下游的中间件或路由进行使用。

![image-20211201075856704](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211201075856704.png)

##### 5.定义多个全局中间件

可以使用 `app.use()` 连续定义多个全局中间件。客户端请求到达服务器之后，会按照中间件定义的先后顺序依次进行调用，示例代码如下：

```javascript
app.use(function (req, res, next) {
  // 第1个全局中间件
  console.log('调用了第1个全局中间件')
  next()
})
app.use(function (req, res, next) {
  // 第2个全局中间件console.log('调用了第2个全局中间件')
  next()
})
app.get('/user', (req, res) => {
  // 请求这个路由，会依次触发上述两个全局中间件
  res.send('Home page.')
})
```

##### 6.局部生效的中间件

不使用 `app.use()` 定义的中间件，叫做局部生效的中间件，示例代码如下：

```javascript
// 定义中间件函数 mw1
const mw1 = function (req, res, next) {
  console.log('这是中间件函数')
  next()
}
// mw1 这个中间件只在"当前路由中生效"，这种用法属于"局部生效的中间件"
app.get('/', mw1, function (req, res) {
  res.send('Home page.')
})
// mw1 这个中间件不会影响下面这个路由↓↓↓
app.get('/user', function (req, res) {
  res.send('User page.')
})
```

##### 7.定义多个局部中间件

可以在路由中，通过如下两种等价的方式，使用多个局部中间件：

```javascript
// 以下两种写法是"完全等价"的，可根据自己的喜好，选择任意一种方式进行使用
app.get('/', mw1, mw2, (req, res) => {
  res.send('Home page.')
})
app.get('/', [mw1, mw2], (req, res) => {
  res.send('Home page.')
})
```

##### 8.了解中间件的5个使用注意事项

①一定要在路由之前注册中间件
②客户端发送过来的请求，可以连续调用多个中间件进行处理
③执行完中间件的业务代码之后，不要忘记调用next() 函数
④为了防止代码逻辑混乱，调用next() 函数后不要再写额外的代码
⑤连续调用多个中间件时，多个中间件之间，共享req 和res 对象

#### 3.3 中间件的分类

为了方便大家理解和记忆中间件的使用，Express 官方把常见的中间件用法，分成了5 大类，分别是：
①应用级别的中间件
②路由级别的中间件
③错误级别的中间件
④Express 内置的中间件
⑤第三方的中间件

##### 1.应用级别的中间件

通过app.use() 或app.get() 或app.post() ，绑定到app 实例上的中间件，叫做应用级别的中间件，代码示例如下：

```javascript
// 应用级别的中间件（全局中间件）
app.use((req, res, next) => {
  next()
})
// 应用级别的中间件（局部中间件)
app.get('/', mw1, (req, res) => {
  res.send('Home page.')
})
```

##### 2.路由级别的中间件

绑定到express.Router() 实例上的中间件，叫做路由级别的中间件。它的用法和应用级别中间件没有任何区别。只不过，应用级别中间件是绑定到app 实例上，路由级别中间件绑定到router 实例上，代码示例如下：

```javascript
var app = express()
var router = express.Router()

// 路由级别的中间件
router.use(function (req, res, next) {
  console.log('Time:', Date.now())
  next()
})

app.use('/', router)
```

##### 3.错误级别的中间件

错误级别中间件的作用：专门用来捕获整个项目中发生的异常错误，从而防止项目异常崩溃的问题。

格式：错误级别中间件的function 处理函数中，必须有4 个形参，形参顺序从前到后，分别是 `(err, req, res, next)`。

```javascript
app.get('/', function (req, res) {
  // 1．路由
  throw new Error('服务器内部发生了错误!') // 1.1抛出一个自定义的错误
})
app.use(function (err, req, res, next) {
  // 2．错误级别的中间件
  console.log('发生了错误:' + err.message) // 2.1在服务器打印错误消息
  res.send('Error! ' + err.message) // 2.2向客户端响应错误相关的内容
})
```


注意：错误级别的中间件，必须注册在所有路由之后！

##### 4.Express内置的中间件

自Express 4.16.0 版本开始，Express 内置了3 个常用的中间件，极大的提高了Express 项目的开发效率和体验：
①express.static快速托管静态资源的内置中间件，例如：HTML 文件、图片、CSS 样式等（无兼容性）
②express.json解析JSON 格式的请求体数据（有兼容性，仅在4.16.0+ 版本中可用）
③express.urlencoded解析URL-encoded 格式的请求体数据（有兼容性，仅在4.16.0+ 版本中可用）

```javascript
// 配置解析application/json格式数据的内置中间件
app.use(express.json())
// 配置解析application/x-www-form-urlencoded格式数据的内置中间件
app.use(express.urlencoded({ extended: false }))
```

##### 5.第三方的中间件

非Express 官方内置的，而是由第三方开发出来的中间件，叫做第三方中间件。在项目中，大家可以按需下载并配置第三方中间件，从而提高项目的开发效率。

例如：在express@4.16.0 之前的版本中，经常使用body-parser 这个第三方中间件，来解析请求体数据。使用步骤如下：
①运行npm install body-parser安装中间件
②使用require导入中间件
③调用app.use() 注册并使用中间件


注意：Express 内置的express.urlencoded中间件，就是基于body-parser 这个第三方中间件进一步封装出来的。

#### 3.4 自定义中间件

##### 1.需求描述与实现步骤

自己手动模拟一个类似于express.urlencoded这样的中间件，来解析POST 提交到服务器的表单数据。

实现步骤：
①定义中间件
②监听req 的data 事件
③监听req 的end 事件
④使用querystring模块解析请求体数据
⑤将解析出来的数据对象挂载为req.body
⑥将自定义中间件封装为模块

##### 2.定义中间件

使用app.use() 来定义全局生效的中间件，代码如下：

```javascript
app.use(function (req, res, next) {
  // 中间件的业务逻辑
})
```

##### 3.监听req 的data事件

在中间件中，需要监听req 对象的data 事件，来获取客户端发送到服务器的数据。

如果数据量比较大，无法一次性发送完毕，则客户端会把数据切割后，分批发送到服务器。所以data 事件可能会触发多次，每一次触发data 事件时，获取到数据只是完整数据的一部分，需要手动对接收到的数据进行拼接。

```javascript
// 定义变量，用来存储客户端发送过来的请求体数据
let str = ''
// 监听req对象的 data 事件(客户端发送过来的新的请求体数据)
req.on('data', chunk => {
  //拼接请求体数据，隐式转换为字符串
  str += chunk
})
```

##### 4.监听req 的end事件

当请求体数据接收完毕之后，会自动触发req 的end 事件。
因此，我们可以在req 的end 事件中，拿到并处理完整的请求体数据。示例代码如下：

```javascript
// 监听req对象的end事件(请求体发送完毕后自动触发)
req.on('end', () => {
  // 打印完整的请求体数据
  console.log(str)
  // TODO:把字符串格式的请求体数据，解析成对象格式
})
```

##### 5.使用querystring模块解析请求体数据

Node.js 内置了一个querystring模块，专门用来处理查询字符串。通过这个模块提供的parse() 函数，可以轻松把查询字符串，解析成对象的格式。示例代码如下：

```javascript
// 导入处理querystring的Node.js内置模块
const qs = require('querystring')

// 调用qs.parse()方法，把查询字符串解析为对象
const body = qs.parse(str)
```

##### 6.将解析出来的数据对象挂载为req.body

上游的中间件和下游的中间件及路由之间，共享同一份req 和res。因此，我们可以将解析出来的数据，挂载为req 的自定义属性，命名为req.body，供下游使用。示例代码如下：

```javascript
req.on('end', () => {
  const body = qs.parse(str) // 调用qs.parse()方法，把查询字符串解析为对象
  req.body = body // 将解析出来的请求体对象，挂载为req.body属性
  next() // 最后，一定要调用next()函数，执行后续的业务逻辑
})
```

##### 7.将自定义中间件封装为模块

为了优化代码的结构，我们可以把自定义的中间件函数，封装为独立的模块，示例代码如下：

```javascript
// custom-body-parser.js模块中的代码
const qs = require('querystring')
function bodyParser(req, res, next) {
  /*省略其它代码*/
}
module.exports = bodyParser // 向外导出解析请求体数据的中间件函数

// ------------------分割线---------------

// 1. 导入自定义的中间件模块
const myBodyParser = require('custom-body-parser')
// 2. 注册自定义的中间件模块
app.use(myBodyParser)
```

### 4.使用Express 写接口

#### 4.1 创建基本的服务器

```javascript
// 导入express模块
const express = require('express')
// 创建express的服务器实例
const app = express()

// write your code here. . .

// 调用app.listen方法，指定端口号并启动web服务器
app.listen(80, function () {
  console.log('Express server running at http://127.0.0.1')
})
```

#### 4.2 创建API 路由模块

```javascript
// apiRouter.js【路由模块】
const express = require('express')
const apiRouter = express.Router()

// bind your router here. ..

module.exports = apiRouter

// ---------------------------

// app.js【导入并注册路由模块】
const apiRouter = require('./apiRouter.js')
app.use('/api', apiRouter)
```

#### 4.3 编写GET 接口

```javascript
apiRouter.get('/get', (req, res) => {
  // 1．获取到客户端通过查询字符串，发送到服务器的数据
  const query = req.query
  // 2．调用res.send()方法，把数据响应给客户端
  res.send({
    status: 0, // 状态，0表示成功，1表示失败
    msg: 'GET请求成功! ', //状态描述
    data: query // 需要响应给客户端的具体数据
  })
})
```

#### 4.4 编写POST 接口

```javascript
apiRouter.post('/post', (req, res) => {
  // 1．获取客户端通过请求体，发送到服务器的URL-encoded数据
  const body = req.body
  // 2．调用res.send()方法，把数据响应给客户端
  res.send({
    status: 0, //状态，0表示成功，1 表示失败
    msg: 'POST请求成功! ', //状态描述消息
    data: body // 需要响应给客户端的具体数据
  })
})
```


注意：如果要获取URL-encoded 格式的请求体数据，必须配置中间件 `app.use(express.urlencoded({ extended: false }))`

#### 4.5 CORS 跨域资源共享

##### 1.接口的跨域问题

刚才编写的GET 和POST接口，存在一个很严重的问题：不支持跨域请求。

解决接口跨域问题的方案主要有两种：
①CORS（主流的解决方案，**推荐使用**）
②JSONP（有缺陷的解决方案：只支持GET 请求）

##### 2.使用cors中间件解决跨域问题

cors是Express 的一个第三方中间件。通过安装和配置cors中间件，可以很方便地解决跨域问题。

使用步骤分为如下3 步：
①运行 `npm install cors` 安装中间件
②使用 `const cors= require('cors')` 导入中间件
③在路由之前调用 `app.use(cors())` 配置中间件

##### 3.什么是CORS

CORS (Cross-Origin Resource Sharing，跨域资源共享) 由一系列HTTP 响应头组成，这些HTTP 响应头决定浏览器是否阻止前端JS 代码跨域获取资源。

浏览器的同源安全策略默认会阻止网页“跨域”获取资源。但如果接口服务器配置了CORS 相关的HTTP 响应头，就可以解除浏览器端的跨域访问限制。

![image-20211201081948775](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211201081948775.png)

##### 4.CORS 的注意事项

①CORS 主要在服务器端进行配置。客户端浏览器无须做任何额外的配置，即可请求开启了CORS 的接口。
②CORS 在浏览器中有兼容性。只有支持XMLHttpRequest Level2 的浏览器，才能正常访问开启了CORS的服务端接口（例如：IE10+、Chrome4+、FireFox3.5+）。

##### 5.CORS 响应头部-Access-Control-Allow-Origin 

响应头部中可以携带一个 `Access-Control-Allow-Origin` 字段，其语法如下:

```
Access-Control-Allow-Origin: <origin> | *
```


其中，origin 参数的值指定了允许访问该资源的外域URL。
例如，下面的字段值将只允许来自http://itcast.cn 的请求：

```
res.setHeader('Access-Control-Allow-origin', 'http:/litcast.cn')
```

如果指定了Access-Control-Allow-Origin 字段的值为通配符*，表示允许来自任何域的请求，示例代码如下：

```
res.setHeader('Access-Control-Allow-origin', '*')
```

##### 6.CORS 响应头部-Access-Control-Allow-Headers

默认情况下，CORS 仅支持客户端向服务器发送如下的9 个请求头：

```
Accept、Accept-Language、Content-Language、DPR、Downlink、Save-Data、Viewport-Width、Width、Content-Type （值仅限于text/plain、multipart/form-data、application/x-www-form-urlencoded三者之一）
```

如果客户端向服务器发送了额外的请求头信息，则需要在服务器端，通过 `Access-Control-Allow-Headers` 对额外的请求头进行声明，否则这次请求会失败！

```
// 允许客户端额外向服务器发送Content-Type请求头和X-Custom-Header请求头
// 注意: 多个请求头之间使用英文的逗号进行分割
res.setHeader('Access-Control-Allow-Headers', 'Content-Type，X-Custom-Header')
```

##### 7.CORS 响应头部-Access-Control-Allow-Methods

默认情况下，CORS 仅支持客户端发起GET、POST、HEAD 请求。

如果客户端希望通过PUT、DELETE等方式请求服务器的资源，则需要在服务器端，通过Access-Control-Alow-Methods来指明实际请求所允许使用的HTTP 方法。

示例代码如下：

```
// 只允许POST、GET、DELETE、HEAD请求方法
res.setHeader('Access-Control-Allow-Methods', 'POST，GET，DELETE，HEAD')
// 允许所有的 HTTP请求方法
res.setHeader('Access-Control-Allow-Methods', '*')
```

##### 8.CORS请求的分类

客户端在请求CORS 接口时，根据请求方式和请求头的不同，可以将CORS 的请求分为两大类，分别是：
①简单请求
②预检请求

##### 9.简单请求

同时满足以下两大条件的请求，就属于简单请求：
①请求方式：GET、POST、HEAD 三者之一
②HTTP 头部信息不超过以下几种字段：无自定义头部字段、Accept、Accept-Language、Content-Language、DPR、Downlink、Save-Data、Viewport-Width、Width 、Content-Type（只有三个值application/x-www-form-urlencoded、multipart/form-data、text/plain）

##### 10.预检请求

只要符合以下任何一个条件的请求，都需要进行预检请求：
①请求方式为GET、POST、HEAD 之外的请求Method 类型
②请求头中包含自定义头部字段
③向服务器发送了application/json 格式的数据


在浏览器与服务器正式通信之前，浏览器会先发送OPTION 请求进行预检，以获知服务器是否允许该实际请求，所以这一次的OPTION 请求称为“预检请求”。服务器成功响应预检请求后，才会发送真正的请求，并且携带真实数据。

##### 11.简单请求和预检请求的区别

简单请求的特点：客户端与服务器之间只会发生一次请求。
预检请求的特点：客户端与服务器之间会发生两次请求，OPTION 预检请求成功之后，才会发起真正的请求。

#### 4.6 JSONP 接口

##### 1.回顾JSONP的概念与特点

概念：浏览器端通过 `<script>` 标签的src 属性，请求服务器上的数据，同时，服务器返回一个函数的调用。这种请求数据的方式叫做JSONP。

特点：
①JSONP 不属于真正的Ajax 请求，因为它没有使用XMLHttpRequest这个对象。
②JSONP 仅支持GET 请求，不支持POST、PUT、DELETE 等请求。

##### 2.创建JSONP 接口的注意事项

如果项目中已经配置了CORS跨域资源共享，为了防止冲突，必须在配置CORS 中间件之前声明JSONP的接口。否则JSONP 接口会被处理成开启了CORS 的接口。示例代码如下：

```javascript
// 优先创建JSONP接口【这个接口不会被处理成CORS 接口】
app.get('/api/jsonp', (req, res) => {})

// 再配置CORS中间件【后续的所有接口，都会被处理成CORS 接口】
app.use(cors())
// 这是一个开启了 CORS的接口
app.get('/api/get', (req, res) => {})
```

##### 3.实现JSONP 接口的步骤

①获取客户端发送过来的回调函数的名字
②得到要通过JSONP 形式发送给客户端的数据
③根据前两步得到的数据，拼接出一个函数调用的字符串
④把上一步拼接得到的字符串，响应给客户端的 `<script>` 标签进行解析执行

##### 4.实现JSONP 接口的具体代码

```javascript
app.get('/api/jsonp', (req, res) => {
  // 1. 获取客户端发送过来的回调函数的名字
  const funcName = req.query.callback
  // 2. 得到要通过JSONP形式发送给客户端的数据
  const data = { name: 'zs ', age: 22 }
  // 3. 根据前两步得到的数据，拼接出一个函数调用的字符串
  const scriptStr = `${funcName}(${JSON.stringify(data)})`
  // 4. 把上一步拼接得到的字符串，响应给客户端的<script>标签进行解析执行
  res.send(scriptStr)
})
```

##### 5.在网页中使用jQuery 发起JSONP 请求

调用 `$.ajax()` 函数，提供JSONP 的配置选项，从而发起JSONP 请求，示例代码如下：

```javascript
$('#btnJSONP').on('click', function () {
  $.ajax({
    method: 'GET',
    url: 'http://127.0.0.1/api/jsonp',
    dataType: 'jsonp ', // 表示要发起JSONP的请求
    success: function (res) {
      console.log(res)
    }
  })
})
```

## 十一、数据库与身份认证 (如果实在需要再回来看)

### 1.数据库的基本概念

#### 1.1 什么是数据库

数据库（database）是用来组织、存储和管理数据的仓库。

当今世界是一个充满着数据的互联网世界，充斥着大量的数据。数据的来源有很多，比如出行记录、消费记录、浏览的网页、发送的消息等等。除了文本类型的数据，图像、音乐、声音都是数据。

为了方便管理互联网世界中的数据，就有了数据库管理系统的概念（简称：数据库）。用户可以对数据库中的数据进行新增、查询、更新、删除等操作。

#### 1.2 常见的数据库及分类

市面上的数据库有很多种，最常见的数据库有如下几个：

- MySQL数据库（目前使用最广泛、流行度最高的开源免费数据库；Community + Enterprise）
- Oracle 数据库（收费）
- SQL Server 数据库（收费）
- Mongodb数据库（Community + Enterprise）

其中，MySQL、Oracle、SQL Server 属于传统型数据库（又叫做：关系型数据库或SQL 数据库），这三者的设计理念相同，用法比较类似。

而Mongodb属于新型数据库（又叫做：非关系型数据库或NoSQL 数据库），它在一定程度上弥补了传统型数据库的缺陷。

#### 1.3 传统型数据库的数据组织结构

数据的组织结构：指的就是数据以什么样的结构进行存储。

传统型数据库的数据组织结构，与Excel 中数据的组织结构比较类似。

因此，我们可以对比着Excel 来了解和学习传统型数据库的数据组织结构。

##### 1.Excel 的数据组织结构

每个Excel 中，数据的组织结构分别为工作簿、工作表、数据行、列这4 大部分组成。

①整个Excel 叫做工作簿
②users 和books 是工作表
③users 工作表中有3 行数据
④每行数据由6 列信息组成
⑤每列信息都有对应的数据类型

##### 2.传统型数据库的数据组织结构

在传统型数据库中，数据的组织结构分为数据库(database)、数据表(table)、数据行(row)、字段(field)这4 大部分组成。

①数据库类似于Excel 的工作簿
②数据表类似于Excel 的工作表
③数据行类似于Excel 的每一行数据
④字段类似于Excel 的列
⑤每个字段都有对应的数据类型

##### 3.实际开发中库、表、行、字段的关系

①在实际项目开发中，一般情况下，每个项目都对应独立的数据库。
②不同的数据，要存储到数据库的不同表中，例如：用户数据存储到users 表中，图书数据存储到books 表中。
③每个表中具体存储哪些信息，由字段来决定，例如：我们可以为users 表设计id、username、password 这3 个字段。
④表中的行，代表每一条具体的数据。

### 2.安装并配置MySQL

#### 2.1 了解需要安装哪些MySQL相关的软件

对于开发人员来说，只需要安装MySQL Server 和MySQL Workbench 这两个软件，就能满足开发的需要了。

- MySQL Server：专门用来提供数据存储和服务的软件。
- MySQL Workbench：可视化的MySQL 管理工具，通过它，可以方便的操作存储在MySQL Server 中的数据。

#### 2.2 MySQL 在Mac 环境下的安装

在Mac 环境下安装MySQL的过程比Windows 环境下的步骤简单很多：

①先运行 mysql-8.0.19-macos10.15-x86_64.dmg 这个安装包，将MySQL Server 安装到Mac 系统
②再运行 mysql-workbench-community-8.0.19-macos-x86_64.dmg 这个安装包，将可视化的MySQL Workbench 工具安装到Mac 系统


具体的安装教程，可以参考 `素材-> MySQL for Mac ->安装教程-Mac系统安装MySql-> README.md`

#### 2.3 MySQL 在Windows 环境下的安装

在Windows 环境下安装MySQL，只需要运行mysql-installer-community-8.0.19.0.msi这个安装包，就能一次性将MySQL Server  和MySQL Workbench 安装到自己的电脑上。

具体的安装教程，可以参考 `素材-> MySQL for Windows ->安装教程-Windows系统安装MySql-> README.md `

### 3.MySQL 的基本使用

#### 3.1 使用MySQL Workbench 管理数据库

##### 1.连接数据库



##### 2.了解主界面的组成部分



##### 3.创建数据库



##### 4.创建数据表


DataType数据类型：
①int整数

②varchar(len) 字符串

③tinyint(1) 布尔值


字段的特殊标识：
①PK（Primary Key）主键、唯一标识

②NN（Not Null）值不允许为空

③UQ（Unique）值唯一

④AI（Auto Increment）值自动增长



##### 5.向表中写入数据



#### 3.2 使用SQL 管理数据库

##### 1.什么是SQL

SQL（英文全称：Structured Query Language）是结构化查询语言，专门用来访问和处理数据库的编程语言。能够让我们以编程的形式，操作数据库里面的数据。
三个关键点：
①SQL 是一门数据库编程语言

②使用SQL 语言编写出来的代码，叫做SQL 语句

③SQL 语言只能在关系型数据库中使用（例如MySQL、Oracle、SQL Server）。非关系型数据库（例如Mongodb）不支持SQL 语言



##### 2.SQL 能做什么

①从数据库中查询数据
②向数据库中插入新的数据
③更新数据库中的数据
④从数据库删除数据
⑤可以创建新数据库
⑥可在数据库中创建新表
⑦可在数据库中创建存储过程、视图
⑧etc…

##### 3.SQL 的学习目标

重点掌握如何使用SQL 从数据表中：
查询数据（select）、插入数据（insert into）、更新数据（update）、删除数据（delete）
额外需要掌握的4 种SQL 语法：
where 条件、and 和or 运算符、order by 排序、count(*) 函数

#### 3.3 SQL 的SELECT 语句

##### 1.语法

SELECT 语句用于从表中查询数据。执行的结果被存储在一个结果表中（称为结果集）。语法格式如下：


注意：SQL 语句中的关键字对大小写不敏感。SELECT 等效于select，FROM 等效于from。

##### 2.SELECT *示例

我们希望从users 表中选取所有的列，可以使用符号* 取代列的名称，示例如下：



##### 3.SELECT 列名称示例

如需获取名为"username" 和"password" 的列的内容（从名为"users" 的数据库表），请使用下面的SELECT 语句：



#### 3.4 SQL 的INSERT INTO 语句

##### 1.语法

INSERT INTO 语句用于向数据表中插入新的数据行，语法格式如下：



##### 2.INSERT INTO 示例

向users 表中，插入一条username 为tony stark，password为098123的用户数据，示例如下：



#### 3.5 SQL 的UPDATE 语句

##### 1.语法

Update 语句用于修改表中的数据。语法格式如下：



##### 2.UPDATE 示例-更新某一行中的一个列

把users 表中id为7的用户密码，更新为888888。示例如下：



##### 3.UPDATE 示例-更新某一行中的若干列

把users 表中id为2的用户密码和用户状态，分别更新为admin123 和1。示例如下：



#### 3.6 SQL 的DELETE 语句

##### 1.语法

DELETE 语句用于删除表中的行。语法格式如下：



##### 2.DELETE 示例

从users 表中，删除id 为4的用户，示例如下：



#### 3.7 SQL 的WHERE 子句

##### 1.语法

WHERE 子句用于限定选择的标准。在SELECT、UPDATE、DELETE语句中，皆可使用WHERE 子句来限定选择的标准。



##### 2.可在WHERE 子句中使用的运算符

下面的运算符可在WHERE 子句中使用，用来限定选择的标准：


注意：在某些版本的SQL 中，操作符<> 可以写为!=

##### 3.WHERE 子句示例

可以通过WHERE 子句来限定SELECT 的查询条件：



#### 3.8 SQL 的AND和OR运算符

##### 1.语法

AND 和OR 可在WHERE 子语句中把两个或多个条件结合起来。
AND 表示必须同时满足多个条件，相当于JavaScript 中的&& 运算符，例如if (a !== 10 &&a !== 20)
OR 表示只要满足任意一个条件即可，相当于JavaScript 中的|| 运算符，例如if(a !== 10 ||a !== 20)

##### 2.AND 运算符示例

使用AND 来显示所有status为0，并且id小于3 的用户：



##### 2.OR 运算符示例

使用OR 来显示所有status为1，或者username为zs 的用户：



#### 3.9 SQL 的ORDER BY 子句

##### 1.语法

ORDER BY 语句用于根据指定的列对结果集进行排序。
ORDER BY 语句默认按照升序对记录进行排序。
如果您希望按照降序对记录进行排序，可以使用DESC关键字。

##### 2.ORDER BY 子句-升序排序

对users 表中的数据，按照status 字段进行升序排序，示例如下：



##### 3.ORDER BY 子句–降序排序

对users 表中的数据，按照id 字段进行降序排序，示例如下：



##### 4.ORDER BY 子句–多重排序

对users 表中的数据，先按照status字段进行降序排序，再按照username的字母顺序，进行升序排序，示例如下：



#### 3.10 SQL 的COUNT(*) 函数

##### 1.语法

COUNT(*) 函数用于返回查询结果的总数据条数，语法格式如下：



##### 2.COUNT(*) 示例

查询users 表中status为0的总数据条数：



##### 2.使用AS 为列设置别名

如果希望给查询出来的列名称设置别名，可以使用AS关键字，示例如下：



### 4.在项目中操作MySQL

#### 4.1 在项目中操作数据库的步骤

①安装操作MySQL 数据库的第三方模块（mysql）

②通过mysql模块连接到MySQL 数据库

③通过mysql模块执行SQL 语句





#### 4.2 安装与配置mysql模块

##### 1.安装mysql模块

mysql模块是托管于npm 上的第三方模块。它提供了在Node.js 项目中连接和操作MySQL 数据库的能力。
想要在项目中使用它，需要先运行如下命令，将mysql安装为项目的依赖包：



##### 2.配置mysql模块

在使用mysql模块操作MySQL 数据库之前，必须先对mysql模块进行必要的配置，主要的配置步骤如下：



##### 3.测试mysql模块能否正常工作

调用db.query() 函数，指定要执行的SQL 语句，通过回调函数拿到执行的结果：



#### 4.3 使用mysql模块操作MySQL 数据库

##### 1.查询数据

查询users 表中所有的数据：



##### 2.插入数据

向users 表中新增数据，其中username为Spider-Man，password为pcc321。示例代码如下：



##### 3.插入数据的便捷方式

向表中新增数据时，如果数据对象的每个属性和数据表的字段一一对应，则可以通过如下方式快速插入数据：



##### 4.更新数据

可以通过如下方式，更新表中的数据：



##### 5.更新数据的便捷方式

更新表数据时，如果数据对象的每个属性和数据表的字段一一对应，则可以通过如下方式快速更新表数据：



##### 6.删除数据

在删除数据时，推荐根据id 这样的唯一标识，来删除对应的数据。示例如下：



##### 7.标记删除

使用DELETE 语句，会把真正的把数据从表中删除掉。为了保险起见，推荐使用标记删除的形式，来模拟删除的动作。
所谓的标记删除，就是在表中设置类似于status这样的状态字段，来标记当前这条数据是否被删除。
当用户执行了删除的动作时，我们并没有执行DELETE 语句把数据删除掉，而是执行了UPDATE 语句，将这条数据对应的status 字段标记为删除即可。



### 5.前后端的身份认证

#### 5.1 Web 开发模式

目前主流的Web 开发模式有两种，分别是：
①基于服务端渲染的传统Web 开发模式

②基于前后端分离的新型Web 开发模式



##### 1.服务端渲染的Web 开发模式

服务端渲染的概念：服务器发送给客户端的HTML 页面，是在服务器通过字符串的拼接，动态生成的。因此，客户端不需要使用Ajax 这样的技术额外请求页面的数据。代码示例如下：



##### 2.服务端渲染的优缺点

优点：
①前端耗时少。因为服务器端负责动态生成HTML 内容，浏览器只需要直接渲染页面即可。尤其是移动端，更省电。

②有利于SEO。因为服务器端响应的是完整的HTML 页面内容，所以爬虫更容易爬取获得信息，更有利于SEO。


缺点：
①占用服务器端资源。即服务器端完成HTML 页面内容的拼接，如果请求较多，会对服务器造成一定的访问压力。

②不利于前后端分离，开发效率低。使用服务器端渲染，则无法进行分工合作，尤其对于前端复杂度高的项目，不利于项目高效开发。



##### 3.前后端分离的Web 开发模式

前后端分离的概念：前后端分离的开发模式，依赖于Ajax 技术的广泛应用。简而言之，前后端分离的Web 开发模式，就是后端只负责提供API 接口，前端使用Ajax 调用接口的开发模式。

##### 4.前后端分离的优缺点

优点：
①开发体验好。前端专注于UI 页面的开发，后端专注于api的开发，且前端有更多的选择性。

②用户体验好。Ajax 技术的广泛应用，极大的提高了用户的体验，可以轻松实现页面的局部刷新。

③减轻了服务器端的渲染压力。因为页面最终是在每个用户的浏览器中生成的。


缺点：
①不利于SEO。因为完整的HTML 页面需要在客户端动态拼接完成，所以爬虫对无法爬取页面的有效信息。（解决方案：利用Vue、React 等前端框架的SSR（server side render）技术能够很好的解决SEO 问题！）



##### 5.如何选择Web 开发模式

不谈业务场景而盲目选择使用何种开发模式都是耍流氓。
.比如企业级网站，主要功能是展示而没有复杂的交互，并且需要良好的SEO，则这时我们就需要使用服务器端渲染；

.而类似后台管理项目，交互性比较强，不需要考虑SEO，那么就可以使用前后端分离的开发模式。


另外，具体使用何种开发模式并不是绝对的，为了同时兼顾了首页的渲染速度和前后端分离的开发效率，一些网站采用了首屏服务器端渲染+ 其他页面前后端分离的开发模式。

#### 5.2 身份认证

##### 1.什么是身份认证

身份认证（Authentication）又称“身份验证”、“鉴权”，是指通过一定的手段，完成对用户身份的确认。
.日常生活中的身份认证随处可见，例如：高铁的验票乘车，手机的密码或指纹解锁，支付宝或微信的支付密码等。

.在Web 开发中，也涉及到用户身份的认证，例如：各大网站的手机验证码登录、邮箱密码登录、二维码登录等。



##### 2.为什么需要身份认证

身份认证的目的，是为了确认当前所声称为某种身份的用户，确实是所声称的用户。例如，你去找快递员取快递，你要怎么证明这份快递是你的。
在互联网项目开发中，如何对用户的身份进行认证，是一个值得深入探讨的问题。例如，如何才能保证网站不会错误的将“马云的存款数额”显示到“马化腾的账户”上。

##### 3.不同开发模式下的身份认证

对于服务端渲染和前后端分离这两种开发模式来说，分别有着不同的身份认证方案：
①服务端渲染推荐使用Session 认证机制

②前后端分离推荐使用JWT 认证机制



#### 5.3 Session 认证机制

##### 1.HTTP 协议的无状态性

了解HTTP 协议的无状态性是进一步学习Session 认证机制的必要前提。
HTTP 协议的无状态性，指的是客户端的每次HTTP 请求都是独立的，连续多个请求之间没有直接的关系，服务器不会主动保留每次HTTP 请求的状态。



##### 2.如何突破HTTP 无状态的限制

对于超市来说，为了方便收银员在进行结算时给VIP 用户打折，超市可以为每个VIP 用户发放会员卡。


注意：现实生活中的会员卡身份认证方式，在Web 开发中的专业术语叫做Cookie。

##### 3.什么是Cookie

Cookie 是存储在用户浏览器中的一段不超过4 KB 的字符串。它由一个名称（Name）、一个值（Value）和其它几个用于控制Cookie 有效期、安全性、使用范围的可选属性组成。
不同域名下的Cookie 各自独立，每当客户端发起请求时，会自动把当前域名下所有未过期的Cookie 一同发送到服务器。
Cookie的几大特性：
①自动发送

②域名独立

③过期时限

④4KB 限制



##### 4.Cookie 在身份认证中的作用

客户端第一次请求服务器的时候，服务器通过响应头的形式，向客户端发送一个身份认证的Cookie，客户端会自动将Cookie 保存在浏览器中。
随后，当客户端浏览器每次请求服务器的时候，浏览器会自动将身份认证相关的Cookie，通过请求头的形式发送给服务器，服务器即可验明客户端的身份。




登录请求


通过响应头，发送Cookie 给浏览器



通过请求头，自动将Cookie 发送给服务器


响应当前用户对应的内容


保存到浏览器中

##### 5.Cookie 不具有安全性

由于Cookie 是存储在浏览器中的，而且浏览器也提供了读写Cookie 的API，因此Cookie 很容易被伪造，不具有安全性。因此不建议服务器将重要的隐私数据，通过Cookie 的形式发送给浏览器。


注意：千万不要使用Cookie 存储重要且隐私的数据！比如用户的身份信息、密码等。

##### 6.提高身份认证的安全性

为了防止客户伪造会员卡，收银员在拿到客户出示的会员卡之后，可以在收银机上进行刷卡认证。只有收银机确认存在的会员卡，才能被正常使用。

这种“会员卡+刷卡认证”的设计理念，就是Session 认证机制的精髓。



##### 7.Session的工作原理



#### 5.4 在Express 中使用Session 认证

##### 1.安装express-session 中间件

在Express 项目中，只需要安装express-session中间件，即可在项目中使用Session 认证：



##### 2.配置express-session 中间件

express-session 中间件安装成功后，需要通过app.use() 来注册session 中间件，示例代码如下：



##### 3.向session 中存数据

当express-session 中间件配置成功后，即可通过req.session来访问和使用session 对象，从而存储用户的关键信息：



##### 4.从session 中取数据

可以直接从req.session对象上获取之前存储的数据，示例代码如下：



##### 5.清空session

调用req.session.destroy() 函数，即可清空服务器保存的session 信息。



#### 5.5 JWT 认证机制

##### 1.了解Session 认证的局限性

Session 认证机制需要配合Cookie才能实现。由于Cookie 默认不支持跨域访问，所以，当涉及到前端跨域请求后端接口的时候，需要做很多额外的配置，才能实现跨域Session 认证。
注意：
.当前端请求后端接口不存在跨域问题的时候，推荐使用Session 身份认证机制。

.当前端需要跨域请求后端接口的时候，不推荐使用Session 身份认证机制，推荐使用JWT 认证机制。



##### 2.什么是JWT

JWT（英文全称：JSON Web Token）是目前最流行的跨域认证解决方案。

##### 3.JWT 的工作原理


总结：用户的信息通过Token 字符串的形式，保存在客户端浏览器中。服务器通过还原Token 字符串的形式来认证用户的身份。

##### 4.JWT 的组成部分

JWT 通常由三部分组成，分别是Header（头部）、Payload（有效荷载）、Signature（签名）。
三者之间使用英文的“.”分隔，格式如下：


下面是JWT 字符串的示例：



##### 6.JWT 的三个部分各自代表的含义

JWT 的三个组成部分，从前到后分别是Header、Payload、Signature。
其中：
.Payload部分才是真正的用户信息，它是用户信息经过加密之后生成的字符串。

.Header 和Signature 是安全性相关的部分，只是为了保证Token 的安全性。





##### 7.JWT 的使用方式

客户端收到服务器返回的JWT 之后，通常会将它储存在localStorage或sessionStorage中。
此后，客户端每次与服务器通信，都要带上这个JWT 的字符串，从而进行身份认证。推荐的做法是把JWT 放在HTTP 请求头的Authorization 字段中，格式如下：



#### 5.6 在Express 中使用JWT

##### 1.安装JWT 相关的包

运行如下命令，安装如下两个JWT 相关的包：


其中：
.jsonwebtoken用于生成JWT 字符串

.express-jwt用于将JWT 字符串解析还原成JSON 对象



##### 2.导入JWT 相关的包

使用require() 函数，分别导入JWT 相关的两个包：



##### 3.定义secret 密钥

为了保证JWT 字符串的安全性，防止JWT 字符串在网络传输过程中被别人破解，我们需要专门定义一个用于加密和解密的secret 密钥：
①当生成JWT 字符串的时候，需要使用secret 密钥对用户的信息进行加密，最终得到加密好的JWT 字符串

②当把JWT 字符串解析还原成JSON 对象的时候，需要使用secret 密钥进行解密





##### 4.在登录成功后生成JWT 字符串

调用jsonwebtoken包提供的sign()方法，将用户的信息加密成JWT 字符串，响应给客户端：



##### 5.将JWT 字符串还原为JSON 对象

客户端每次在访问那些有权限接口的时候，都需要主动通过请求头中的Authorization 字段，将Token 字符串发送到服务器进行身份认证。
此时，服务器可以通过express-jwt这个中间件，自动将客户端发送过来的Token 解析还原成JSON 对象：



##### 6.使用req.user获取用户信息

当express-jwt这个中间件配置成功之后，即可在那些有权限的接口中，使用req.user对象，来访问从JWT 字符串中解析出来的用户信息了，示例代码如下：



##### 7.捕获解析JWT 失败后产生的错误

当使用express-jwt解析Token 字符串时，如果客户端发送过来的Token 字符串过期或不合法，会产生一个解析失败的错误，影响项目的正常运行。我们可以通过Express 的错误中间件，捕获这个错误并进行相关的处理，示例代码如下：

## 十二、案例2--完善大事件案例(略)

略

## P657结束

